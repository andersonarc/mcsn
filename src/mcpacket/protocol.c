/*
  This file was generated by mcd2c.py
  It should not be edited by hand.
*/

#include "protocol.h"

const char* serverbound_handshaking_cstrings[] = {
  "ServerboundSetProtocol"
};

const char* clientbound_status_cstrings[] = {
  "ClientboundServerInfo",
  "ClientboundPing"
};

const char* serverbound_status_cstrings[] = {
  "ServerboundPingStart",
  "ServerboundPing"
};

const char* clientbound_login_cstrings[] = {
  "ClientboundDisconnect",
  "ClientboundEncryptionBegin",
  "ClientboundSuccess",
  "ClientboundCompress",
  "ClientboundLoginPluginRequest"
};

const char* serverbound_login_cstrings[] = {
  "ServerboundLoginStart",
  "ServerboundEncryptionBegin",
  "ServerboundLoginPluginResponse"
};

const char* clientbound_play_cstrings[] = {
  "ClientboundSpawnEntity",
  "ClientboundSpawnEntityExperienceOrb",
  "ClientboundSpawnEntityLiving",
  "ClientboundSpawnEntityPainting",
  "ClientboundNamedEntitySpawn",
  "ClientboundAnimation",
  "ClientboundStatistics",
  "ClientboundAcknowledgePlayerDigging",
  "ClientboundBlockBreakAnimation",
  "ClientboundTileEntityData",
  "ClientboundBlockAction",
  "ClientboundBlockChange",
  "ClientboundBossBar",
  "ClientboundDifficulty",
  "ClientboundChat",
  "ClientboundMultiBlockChange",
  "ClientboundTabComplete",
  "ClientboundDeclareCommands",
  "ClientboundTransaction",
  "ClientboundCloseWindow",
  "ClientboundWindowItems",
  "ClientboundCraftProgressBar",
  "ClientboundSetSlot",
  "ClientboundSetCooldown",
  "ClientboundCustomPayload",
  "ClientboundNamedSoundEffect",
  "ClientboundKickDisconnect",
  "ClientboundEntityStatus",
  "ClientboundExplosion",
  "ClientboundUnloadChunk",
  "ClientboundGameStateChange",
  "ClientboundOpenHorseWindow",
  "ClientboundKeepAlive",
  "ClientboundMapChunk",
  "ClientboundWorldEvent",
  "ClientboundWorldParticles",
  "ClientboundUpdateLight",
  "ClientboundLogin",
  "ClientboundMap",
  "ClientboundTradeList",
  "ClientboundRelEntityMove",
  "ClientboundEntityMoveLook",
  "ClientboundEntityLook",
  "ClientboundEntity",
  "ClientboundVehicleMove",
  "ClientboundOpenBook",
  "ClientboundOpenWindow",
  "ClientboundOpenSignEntity",
  "ClientboundCraftRecipeResponse",
  "ClientboundAbilities",
  "ClientboundCombatEvent",
  "ClientboundPlayerInfo",
  "ClientboundFacePlayer",
  "ClientboundPosition",
  "ClientboundUnlockRecipes",
  "ClientboundEntityDestroy",
  "ClientboundRemoveEntityEffect",
  "ClientboundResourcePackSend",
  "ClientboundRespawn",
  "ClientboundEntityHeadRotation",
  "ClientboundSelectAdvancementTab",
  "ClientboundWorldBorder",
  "ClientboundCamera",
  "ClientboundHeldItemSlot",
  "ClientboundUpdateViewPosition",
  "ClientboundUpdateViewDistance",
  "ClientboundSpawnPosition",
  "ClientboundScoreboardDisplayObjective",
  "ClientboundEntityMetadata",
  "ClientboundAttachEntity",
  "ClientboundEntityVelocity",
  "ClientboundEntityEquipment",
  "ClientboundExperience",
  "ClientboundUpdateHealth",
  "ClientboundScoreboardObjective",
  "ClientboundSetPassengers",
  "ClientboundTeams",
  "ClientboundScoreboardScore",
  "ClientboundUpdateTime",
  "ClientboundTitle",
  "ClientboundEntitySoundEffect",
  "ClientboundSoundEffect",
  "ClientboundStopSound",
  "ClientboundPlayerlistHeader",
  "ClientboundNbtQueryResponse",
  "ClientboundCollect",
  "ClientboundEntityTeleport",
  "ClientboundAdvancements",
  "ClientboundEntityUpdateAttributes",
  "ClientboundEntityEffect",
  "ClientboundDeclareRecipes",
  "ClientboundTags"
};

const char* serverbound_play_cstrings[] = {
  "ServerboundTeleportConfirm",
  "ServerboundQueryBlockNbt",
  "ServerboundSetDifficulty",
  "ServerboundChat",
  "ServerboundClientCommand",
  "ServerboundSettings",
  "ServerboundTabComplete",
  "ServerboundTransaction",
  "ServerboundEnchantItem",
  "ServerboundWindowClick",
  "ServerboundCloseWindow",
  "ServerboundCustomPayload",
  "ServerboundEditBook",
  "ServerboundQueryEntityNbt",
  "ServerboundUseEntity",
  "ServerboundGenerateStructure",
  "ServerboundKeepAlive",
  "ServerboundLockDifficulty",
  "ServerboundPosition",
  "ServerboundPositionLook",
  "ServerboundLook",
  "ServerboundFlying",
  "ServerboundVehicleMove",
  "ServerboundSteerBoat",
  "ServerboundPickItem",
  "ServerboundCraftRecipeRequest",
  "ServerboundAbilities",
  "ServerboundBlockDig",
  "ServerboundEntityAction",
  "ServerboundSteerVehicle",
  "ServerboundCraftingBookData",
  "ServerboundNameItem",
  "ServerboundResourcePackReceive",
  "ServerboundAdvancementTab",
  "ServerboundSelectTrade",
  "ServerboundSetBeaconEffect",
  "ServerboundHeldItemSlot",
  "ServerboundUpdateCommandBlock",
  "ServerboundUpdateCommandBlockMinecart",
  "ServerboundSetCreativeSlot",
  "ServerboundUpdateJigsawBlock",
  "ServerboundUpdateStructureBlock",
  "ServerboundUpdateSign",
  "ServerboundArmAnimation",
  "ServerboundSpectate",
  "ServerboundBlockPlace",
  "ServerboundUseItem"
};

const char **protocol_cstrings[STATE_MAX][DIRECTION_MAX] = {
  {serverbound_handshaking_cstrings},
  {serverbound_status_cstrings, clientbound_status_cstrings},
  {serverbound_login_cstrings, clientbound_login_cstrings},
  {serverbound_play_cstrings, clientbound_play_cstrings}
};

const int protocol_max_ids[STATE_MAX][DIRECTION_MAX] = {
  {SERVERBOUND_HANDSHAKING_MAX, CLIENTBOUND_HANDSHAKING_MAX},
  {SERVERBOUND_STATUS_MAX, CLIENTBOUND_STATUS_MAX},
  {SERVERBOUND_LOGIN_MAX, CLIENTBOUND_LOGIN_MAX},
  {SERVERBOUND_PLAY_MAX, CLIENTBOUND_PLAY_MAX}
};

void ServerboundSetProtocol_encode(FILE* dest, ServerboundSetProtocol* this) {
  enc_varint(dest, this->protocolVersion);
  enc_string(dest, this->serverHost);
  enc_be16(dest, this->serverPort);
  enc_varint(dest, this->nextState);
}
void ServerboundSetProtocol_decode(FILE* src, ServerboundSetProtocol* this) {
  this->protocolVersion = dec_varint(src);
  this->serverHost = dec_string(src);
  this->serverPort = dec_be16(src);
  this->nextState = dec_varint(src);
}

void ServerboundLegacyServerListPing_encode(FILE* dest, ServerboundLegacyServerListPing* this) {
  enc_byte(dest, this->payload);
}
void ServerboundLegacyServerListPing_decode(FILE* src, ServerboundLegacyServerListPing* this) {
  this->payload = dec_byte(src);
}

void ClientboundServerInfo_encode(FILE* dest, ClientboundServerInfo* this) {
  enc_string(dest, this->response);
}
void ClientboundServerInfo_decode(FILE* src, ClientboundServerInfo* this) {
  this->response = dec_string(src);
}

void ClientboundPing_encode(FILE* dest, ClientboundPing* this) {
  enc_be64(dest, this->time);
}
void ClientboundPing_decode(FILE* src, ClientboundPing* this) {
  this->time = dec_be64(src);
}

void ServerboundPingStart_encode(FILE* dest, ServerboundPingStart* this) {
}
void ServerboundPingStart_decode(FILE* src, ServerboundPingStart* this) {
}

void ServerboundPing_encode(FILE* dest, ServerboundPing* this) {
  enc_be64(dest, this->time);
}
void ServerboundPing_decode(FILE* src, ServerboundPing* this) {
  this->time = dec_be64(src);
}

void ClientboundDisconnect_encode(FILE* dest, ClientboundDisconnect* this) {
  enc_string(dest, this->reason);
}
void ClientboundDisconnect_decode(FILE* src, ClientboundDisconnect* this) {
  this->reason = dec_string(src);
}

void ClientboundEncryptionBegin_encode(FILE* dest, ClientboundEncryptionBegin* this) {
  enc_string(dest, this->serverId);
  enc_varint(dest, this->publicKey.size);
  enc_buffer(dest, this->publicKey);
  enc_varint(dest, this->verifyToken.size);
  enc_buffer(dest, this->verifyToken);
}
void ClientboundEncryptionBegin_decode(FILE* src, ClientboundEncryptionBegin* this) {
  this->serverId = dec_string(src);
  this->publicKey = dec_buffer(src, dec_varint(src));
  this->verifyToken = dec_buffer(src, dec_varint(src));
}

void ClientboundSuccess_encode(FILE* dest, ClientboundSuccess* this) {
  enc_uuid(dest, this->uuid);
  enc_string(dest, this->username);
}
void ClientboundSuccess_decode(FILE* src, ClientboundSuccess* this) {
  this->uuid = dec_uuid(src);
  this->username = dec_string(src);
}

void ClientboundCompress_encode(FILE* dest, ClientboundCompress* this) {
  enc_varint(dest, this->threshold);
}
void ClientboundCompress_decode(FILE* src, ClientboundCompress* this) {
  this->threshold = dec_varint(src);
}

void ClientboundLoginPluginRequest_encode(FILE* dest, ClientboundLoginPluginRequest* this) {
  enc_varint(dest, this->messageId);
  enc_string(dest, this->channel);
  fwrite(this->data.data, sizeof(char), this->data.size, dest);
}
void ClientboundLoginPluginRequest_decode(FILE* src, ClientboundLoginPluginRequest* this) {
  this->messageId = dec_varint(src);
  this->channel = dec_string(src);
  this->data.size = 0; /* todo */
}

void ServerboundLoginStart_encode(FILE* dest, ServerboundLoginStart* this) {
  enc_string(dest, this->username);
}
void ServerboundLoginStart_decode(FILE* src, ServerboundLoginStart* this) {
  this->username = dec_string(src);
}

void ServerboundEncryptionBegin_encode(FILE* dest, ServerboundEncryptionBegin* this) {
  enc_varint(dest, this->sharedSecret.size);
  enc_buffer(dest, this->sharedSecret);
  enc_varint(dest, this->verifyToken.size);
  enc_buffer(dest, this->verifyToken);
}
void ServerboundEncryptionBegin_decode(FILE* src, ServerboundEncryptionBegin* this) {
  this->sharedSecret = dec_buffer(src, dec_varint(src));
  this->verifyToken = dec_buffer(src, dec_varint(src));
}

void ServerboundLoginPluginResponse_encode(FILE* dest, ServerboundLoginPluginResponse* this) {
  enc_varint(dest, this->messageId);
  enc_byte(dest, this->data.has_value);
  if (this->data.has_value) {
    fwrite(this->data.value.data, sizeof(char), this->data.value.size, dest);
  }
}
void ServerboundLoginPluginResponse_decode(FILE* src, ServerboundLoginPluginResponse* this) {
  this->messageId = dec_varint(src);
  if (dec_byte(src)) {
    this->data.has_value = true;
    this->data.value.size = 0; /* todo */
  }
}

void ClientboundSpawnEntity_encode(FILE* dest, ClientboundSpawnEntity* this) {
  enc_varint(dest, this->entityId);
  enc_uuid(dest, this->objectUUID);
  enc_varint(dest, this->type);
  enc_bef64(dest, this->x);
  enc_bef64(dest, this->y);
  enc_bef64(dest, this->z);
  enc_byte(dest, this->pitch);
  enc_byte(dest, this->yaw);
  enc_be32(dest, this->objectData);
  enc_be16(dest, this->velocityX);
  enc_be16(dest, this->velocityY);
  enc_be16(dest, this->velocityZ);
}
void ClientboundSpawnEntity_decode(FILE* src, ClientboundSpawnEntity* this) {
  this->entityId = dec_varint(src);
  this->objectUUID = dec_uuid(src);
  this->type = dec_varint(src);
  this->x = dec_bef64(src);
  this->y = dec_bef64(src);
  this->z = dec_bef64(src);
  this->pitch = dec_byte(src);
  this->yaw = dec_byte(src);
  this->objectData = dec_be32(src);
  this->velocityX = dec_be16(src);
  this->velocityY = dec_be16(src);
  this->velocityZ = dec_be16(src);
}

void ClientboundSpawnEntityExperienceOrb_encode(FILE* dest, ClientboundSpawnEntityExperienceOrb* this) {
  enc_varint(dest, this->entityId);
  enc_bef64(dest, this->x);
  enc_bef64(dest, this->y);
  enc_bef64(dest, this->z);
  enc_be16(dest, this->count);
}
void ClientboundSpawnEntityExperienceOrb_decode(FILE* src, ClientboundSpawnEntityExperienceOrb* this) {
  this->entityId = dec_varint(src);
  this->x = dec_bef64(src);
  this->y = dec_bef64(src);
  this->z = dec_bef64(src);
  this->count = dec_be16(src);
}

void ClientboundSpawnEntityLiving_encode(FILE* dest, ClientboundSpawnEntityLiving* this) {
  enc_varint(dest, this->entityId);
  enc_uuid(dest, this->entityUUID);
  enc_varint(dest, this->type);
  enc_bef64(dest, this->x);
  enc_bef64(dest, this->y);
  enc_bef64(dest, this->z);
  enc_byte(dest, this->yaw);
  enc_byte(dest, this->pitch);
  enc_byte(dest, this->headPitch);
  enc_be16(dest, this->velocityX);
  enc_be16(dest, this->velocityY);
  enc_be16(dest, this->velocityZ);
}
void ClientboundSpawnEntityLiving_decode(FILE* src, ClientboundSpawnEntityLiving* this) {
  this->entityId = dec_varint(src);
  this->entityUUID = dec_uuid(src);
  this->type = dec_varint(src);
  this->x = dec_bef64(src);
  this->y = dec_bef64(src);
  this->z = dec_bef64(src);
  this->yaw = dec_byte(src);
  this->pitch = dec_byte(src);
  this->headPitch = dec_byte(src);
  this->velocityX = dec_be16(src);
  this->velocityY = dec_be16(src);
  this->velocityZ = dec_be16(src);
}

void ClientboundSpawnEntityPainting_encode(FILE* dest, ClientboundSpawnEntityPainting* this) {
  enc_varint(dest, this->entityId);
  enc_uuid(dest, this->entityUUID);
  enc_varint(dest, this->title);
  enc_position(dest, this->location);
  enc_byte(dest, this->direction);
}
void ClientboundSpawnEntityPainting_decode(FILE* src, ClientboundSpawnEntityPainting* this) {
  this->entityId = dec_varint(src);
  this->entityUUID = dec_uuid(src);
  this->title = dec_varint(src);
  this->location = dec_position(src);
  this->direction = dec_byte(src);
}

void ClientboundNamedEntitySpawn_encode(FILE* dest, ClientboundNamedEntitySpawn* this) {
  enc_varint(dest, this->entityId);
  enc_uuid(dest, this->playerUUID);
  enc_bef64(dest, this->x);
  enc_bef64(dest, this->y);
  enc_bef64(dest, this->z);
  enc_byte(dest, this->yaw);
  enc_byte(dest, this->pitch);
}
void ClientboundNamedEntitySpawn_decode(FILE* src, ClientboundNamedEntitySpawn* this) {
  this->entityId = dec_varint(src);
  this->playerUUID = dec_uuid(src);
  this->x = dec_bef64(src);
  this->y = dec_bef64(src);
  this->z = dec_bef64(src);
  this->yaw = dec_byte(src);
  this->pitch = dec_byte(src);
}

void ClientboundAnimation_encode(FILE* dest, ClientboundAnimation* this) {
  enc_varint(dest, this->entityId);
  enc_byte(dest, this->animation);
}
void ClientboundAnimation_decode(FILE* src, ClientboundAnimation* this) {
  this->entityId = dec_varint(src);
  this->animation = dec_byte(src);
}

void ClientboundStatistics_encode(FILE* dest, ClientboundStatistics* this) {
  enc_varint(dest, this->entries.size);
  for (int i0 = 0; i0 < this->entries.size; i0++) {
    enc_varint(dest, this->entries.data[i0].categoryId);
    enc_varint(dest, this->entries.data[i0].statisticId);
    enc_varint(dest, this->entries.data[i0].value);
  }
}
void ClientboundStatistics_decode(FILE* src, ClientboundStatistics* this) {
  this->entries.size = dec_varint(src);
  this->entries.data = (Statistics_entries_type*) malloc(this->entries.size * sizeof(Statistics_entries_type));
  for (int i0 = 0; i0 < this->entries.size; i0++) {
    this->entries.data[i0].categoryId = dec_varint(src);
    this->entries.data[i0].statisticId = dec_varint(src);
    this->entries.data[i0].value = dec_varint(src);
  }
}

void ClientboundAcknowledgePlayerDigging_encode(FILE* dest, ClientboundAcknowledgePlayerDigging* this) {
  enc_position(dest, this->location);
  enc_varint(dest, this->block);
  enc_varint(dest, this->status);
  enc_byte(dest, this->successful);
}
void ClientboundAcknowledgePlayerDigging_decode(FILE* src, ClientboundAcknowledgePlayerDigging* this) {
  this->location = dec_position(src);
  this->block = dec_varint(src);
  this->status = dec_varint(src);
  this->successful = dec_byte(src);
}

void ClientboundBlockBreakAnimation_encode(FILE* dest, ClientboundBlockBreakAnimation* this) {
  enc_varint(dest, this->entityId);
  enc_position(dest, this->location);
  enc_byte(dest, this->destroyStage);
}
void ClientboundBlockBreakAnimation_decode(FILE* src, ClientboundBlockBreakAnimation* this) {
  this->entityId = dec_varint(src);
  this->location = dec_position(src);
  this->destroyStage = dec_byte(src);
}

void ClientboundTileEntityData_encode(FILE* dest, ClientboundTileEntityData* this) {
  enc_position(dest, this->location);
  enc_byte(dest, this->action);
  if (this->nbtData.has_value) {
    encode_full(dest, this->nbtData.value);
  } else {
    enc_byte(dest, NBT_TAG_END);
  }
}
void ClientboundTileEntityData_decode(FILE* src, ClientboundTileEntityData* this) {
  this->location = dec_position(src);
  this->action = dec_byte(src);
  if (dec_byte(src) == NBT_TAG_COMPOUND) {
    this->nbtData.has_value = true;
    this->nbtData.value = nbt_read_string(src);
  }
}

void ClientboundBlockAction_encode(FILE* dest, ClientboundBlockAction* this) {
  enc_position(dest, this->location);
  enc_byte(dest, this->byte1);
  enc_byte(dest, this->byte2);
  enc_varint(dest, this->blockId);
}
void ClientboundBlockAction_decode(FILE* src, ClientboundBlockAction* this) {
  this->location = dec_position(src);
  this->byte1 = dec_byte(src);
  this->byte2 = dec_byte(src);
  this->blockId = dec_varint(src);
}

void ClientboundBlockChange_encode(FILE* dest, ClientboundBlockChange* this) {
  enc_position(dest, this->location);
  enc_varint(dest, this->type);
}
void ClientboundBlockChange_decode(FILE* src, ClientboundBlockChange* this) {
  this->location = dec_position(src);
  this->type = dec_varint(src);
}

void ClientboundBossBar_encode(FILE* dest, ClientboundBossBar* this) {
  enc_uuid(dest, this->entityUUID);
  enc_varint(dest, this->action);
  switch (this->action) {
    case 0:
      enc_string(dest, this->title);
      enc_bef32(dest, this->health);
      enc_varint(dest, this->color);
      enc_varint(dest, this->dividers);
      enc_byte(dest, this->flags);
      break;
    case 2:
      enc_bef32(dest, this->health);
      break;
    case 3:
      enc_string(dest, this->title);
      break;
    case 4:
      enc_varint(dest, this->color);
      enc_varint(dest, this->dividers);
      break;
    case 5:
      enc_byte(dest, this->flags);
      break;
  }
}
void ClientboundBossBar_decode(FILE* src, ClientboundBossBar* this) {
  this->entityUUID = dec_uuid(src);
  this->action = dec_varint(src);
  switch (this->action) {
    case 0:
      this->title = dec_string(src);
      this->health = dec_bef32(src);
      this->color = dec_varint(src);
      this->dividers = dec_varint(src);
      this->flags = dec_byte(src);
      break;
    case 2:
      this->health = dec_bef32(src);
      break;
    case 3:
      this->title = dec_string(src);
      break;
    case 4:
      this->color = dec_varint(src);
      this->dividers = dec_varint(src);
      break;
    case 5:
      this->flags = dec_byte(src);
      break;
  }
}

void ClientboundDifficulty_encode(FILE* dest, ClientboundDifficulty* this) {
  enc_byte(dest, this->difficulty);
  enc_byte(dest, this->difficultyLocked);
}
void ClientboundDifficulty_decode(FILE* src, ClientboundDifficulty* this) {
  this->difficulty = dec_byte(src);
  this->difficultyLocked = dec_byte(src);
}

void ClientboundChat_encode(FILE* dest, ClientboundChat* this) {
  enc_string(dest, this->message);
  enc_byte(dest, this->position);
  enc_uuid(dest, this->sender);
}
void ClientboundChat_decode(FILE* src, ClientboundChat* this) {
  this->message = dec_string(src);
  this->position = dec_byte(src);
  this->sender = dec_uuid(src);
}

void ClientboundMultiBlockChange_encode(FILE* dest, ClientboundMultiBlockChange* this) {
  enc_be32(dest, this->chunkX);
  enc_be32(dest, this->chunkZ);
  enc_varint(dest, this->records.size);
  for (int i0 = 0; i0 < this->records.size; i0++) {
    enc_byte(dest, this->records.data[i0].horizontalPos);
    enc_byte(dest, this->records.data[i0].y);
    enc_varint(dest, this->records.data[i0].blockId);
  }
}
void ClientboundMultiBlockChange_decode(FILE* src, ClientboundMultiBlockChange* this) {
  this->chunkX = dec_be32(src);
  this->chunkZ = dec_be32(src);
  this->records.size = dec_varint(src);
  this->records.data = (MultiBlockChange_records_type*) malloc(this->records.size * sizeof(MultiBlockChange_records_type));
  for (int i0 = 0; i0 < this->records.size; i0++) {
    this->records.data[i0].horizontalPos = dec_byte(src);
    this->records.data[i0].y = dec_byte(src);
    this->records.data[i0].blockId = dec_varint(src);
  }
}

void ClientboundTabComplete_encode(FILE* dest, ClientboundTabComplete* this) {
  enc_varint(dest, this->transactionId);
  enc_varint(dest, this->start);
  enc_varint(dest, this->length);
  enc_varint(dest, this->matches.size);
  for (int i0 = 0; i0 < this->matches.size; i0++) {
    enc_string(dest, this->matches.data[i0].match);
    enc_byte(dest, this->matches.data[i0].tooltip.has_value);
    if (this->matches.data[i0].tooltip.has_value) {
      enc_string(dest, this->matches.data[i0].tooltip.value);
    }
  }
}
void ClientboundTabComplete_decode(FILE* src, ClientboundTabComplete* this) {
  this->transactionId = dec_varint(src);
  this->start = dec_varint(src);
  this->length = dec_varint(src);
  this->matches.size = dec_varint(src);
  this->matches.data = (TabComplete_matches_type*) malloc(this->matches.size * sizeof(TabComplete_matches_type));
  for (int i0 = 0; i0 < this->matches.size; i0++) {
    this->matches.data[i0].match = dec_string(src);
    if (dec_byte(src)) {
      this->matches.data[i0].tooltip.has_value = true;
      this->matches.data[i0].tooltip.value = dec_string(src);
    }
  }
}

void ClientboundDeclareCommands_encode(FILE* dest, ClientboundDeclareCommands* this) {
  enc_varint(dest, this->nodes.size);
  for (int i0 = 0; i0 < this->nodes.size; i0++) {
    uint8_t flags_ = 0;
    flags_ |= (((uint8_t) this->nodes.data[i0].flags.has_custom_suggestions) & 1) << 4;
    flags_ |= (((uint8_t) this->nodes.data[i0].flags.has_redirect_node) & 1) << 3;
    flags_ |= (((uint8_t) this->nodes.data[i0].flags.has_command) & 1) << 2;
    flags_ |= (((uint8_t) this->nodes.data[i0].flags.command_node_type) & 3);
    enc_byte(dest, flags_);
    enc_varint(dest, this->nodes.data[i0].children.size);
    for (int i2 = 0; i2 < this->nodes.data[i0].children.size; i2++) {
      enc_varint(dest, this->nodes.data[i0].children.data[i2]);
    }
    if (this->nodes.data[i0].flags.has_redirect_node == 1) {
      enc_varint(dest, this->nodes.data[i0].redirectNode);
    }
    switch (this->nodes.data[i0].flags.command_node_type) {
      case 1:
        enc_string(dest, this->nodes.data[i0].extraNodeData_1);
        break;
      case 2:
        enc_string(dest, this->nodes.data[i0].extraNodeData_2.name);
        enc_string(dest, this->nodes.data[i0].extraNodeData_2.parser);
        if (!strcmp(this->nodes.data[i0].extraNodeData_2.parser, "brigadier:double")) {
          uint8_t flags_ = 0;
          flags_ |= (((uint8_t) this->nodes.data[i0].extraNodeData_2.brigadier_double.flags.max_present) & 1) << 1;
          flags_ |= (((uint8_t) this->nodes.data[i0].extraNodeData_2.brigadier_double.flags.min_present) & 1);
          enc_byte(dest, flags_);
          if (this->nodes.data[i0].extraNodeData_2.brigadier_double.flags.min_present == 1) {
            enc_bef64(dest, this->nodes.data[i0].extraNodeData_2.brigadier_double.min);
          }
          if (this->nodes.data[i0].extraNodeData_2.brigadier_double.flags.max_present == 1) {
            enc_bef64(dest, this->nodes.data[i0].extraNodeData_2.brigadier_double.max);
          }
        } else if (!strcmp(this->nodes.data[i0].extraNodeData_2.parser, "brigadier:float")) {
          uint8_t flags_ = 0;
          flags_ |= (((uint8_t) this->nodes.data[i0].extraNodeData_2.brigadier_float.flags.max_present) & 1) << 1;
          flags_ |= (((uint8_t) this->nodes.data[i0].extraNodeData_2.brigadier_float.flags.min_present) & 1);
          enc_byte(dest, flags_);
          if (this->nodes.data[i0].extraNodeData_2.brigadier_float.flags.min_present == 1) {
            enc_bef32(dest, this->nodes.data[i0].extraNodeData_2.brigadier_float.min);
          }
          if (this->nodes.data[i0].extraNodeData_2.brigadier_float.flags.max_present == 1) {
            enc_bef32(dest, this->nodes.data[i0].extraNodeData_2.brigadier_float.max);
          }
        } else if (!strcmp(this->nodes.data[i0].extraNodeData_2.parser, "brigadier:integer")) {
          uint8_t flags_ = 0;
          flags_ |= (((uint8_t) this->nodes.data[i0].extraNodeData_2.brigadier_integer.flags.max_present) & 1) << 1;
          flags_ |= (((uint8_t) this->nodes.data[i0].extraNodeData_2.brigadier_integer.flags.min_present) & 1);
          enc_byte(dest, flags_);
          if (this->nodes.data[i0].extraNodeData_2.brigadier_integer.flags.min_present == 1) {
            enc_be32(dest, this->nodes.data[i0].extraNodeData_2.brigadier_integer.min);
          }
          if (this->nodes.data[i0].extraNodeData_2.brigadier_integer.flags.max_present == 1) {
            enc_be32(dest, this->nodes.data[i0].extraNodeData_2.brigadier_integer.max);
          }
        } else if (!strcmp(this->nodes.data[i0].extraNodeData_2.parser, "brigadier:string")) {
          enc_varint(dest, this->nodes.data[i0].extraNodeData_2.brigadier_string);
        } else if (!strcmp(this->nodes.data[i0].extraNodeData_2.parser, "minecraft:entity")) {
          enc_byte(dest, this->nodes.data[i0].extraNodeData_2.minecraft_entity);
        } else if (!strcmp(this->nodes.data[i0].extraNodeData_2.parser, "minecraft:score_holder")) {
          enc_byte(dest, this->nodes.data[i0].extraNodeData_2.minecraft_score_holder);
        }
        if (this->nodes.data[i0].flags.has_custom_suggestions == 1) {
          enc_string(dest, this->nodes.data[i0].extraNodeData_2.suggests);
        }
        break;
    }
  }
  enc_varint(dest, this->rootIndex);
}
void ClientboundDeclareCommands_decode(FILE* src, ClientboundDeclareCommands* this) {
  this->nodes.size = dec_varint(src);
  this->nodes.data = (DeclareCommands_nodes_type*) malloc(this->nodes.size * sizeof(DeclareCommands_nodes_type));
  for (int i0 = 0; i0 < this->nodes.size; i0++) {
    uint8_t flags_ = dec_byte(src);
    this->nodes.data[i0].flags.has_custom_suggestions = (flags_ >> 4) & 1;
    this->nodes.data[i0].flags.has_redirect_node = (flags_ >> 3) & 1;
    this->nodes.data[i0].flags.has_command = (flags_ >> 2) & 1;
    this->nodes.data[i0].flags.command_node_type = (flags_) & 3;
    this->nodes.data[i0].children.size = dec_varint(src);
    this->nodes.data[i0].children.data = (int64_t*) malloc(this->nodes.data[i0].children.size * sizeof(int64_t));
    for (int i2 = 0; i2 < this->nodes.data[i0].children.size; i2++) {
      this->nodes.data[i0].children.data[i2] = dec_varint(src);
    }
    if (this->nodes.data[i0].flags.has_redirect_node == 1) {
      this->nodes.data[i0].redirectNode = dec_varint(src);
    }
    switch (this->nodes.data[i0].flags.command_node_type) {
      case 1:
        this->nodes.data[i0].extraNodeData_1 = dec_string(src);
        break;
      case 2:
        this->nodes.data[i0].extraNodeData_2.name = dec_string(src);
        this->nodes.data[i0].extraNodeData_2.parser = dec_string(src);
        if (!strcmp(this->nodes.data[i0].extraNodeData_2.parser, "brigadier:double")) {
          uint8_t flags_ = dec_byte(src);
          this->nodes.data[i0].extraNodeData_2.brigadier_double.flags.max_present = (flags_ >> 1) & 1;
          this->nodes.data[i0].extraNodeData_2.brigadier_double.flags.min_present = (flags_) & 1;
          if (this->nodes.data[i0].extraNodeData_2.brigadier_double.flags.min_present == 1) {
            this->nodes.data[i0].extraNodeData_2.brigadier_double.min = dec_bef64(src);
          }
          if (this->nodes.data[i0].extraNodeData_2.brigadier_double.flags.max_present == 1) {
            this->nodes.data[i0].extraNodeData_2.brigadier_double.max = dec_bef64(src);
          }
        } else if (!strcmp(this->nodes.data[i0].extraNodeData_2.parser, "brigadier:float")) {
          uint8_t flags_ = dec_byte(src);
          this->nodes.data[i0].extraNodeData_2.brigadier_float.flags.max_present = (flags_ >> 1) & 1;
          this->nodes.data[i0].extraNodeData_2.brigadier_float.flags.min_present = (flags_) & 1;
          if (this->nodes.data[i0].extraNodeData_2.brigadier_float.flags.min_present == 1) {
            this->nodes.data[i0].extraNodeData_2.brigadier_float.min = dec_bef32(src);
          }
          if (this->nodes.data[i0].extraNodeData_2.brigadier_float.flags.max_present == 1) {
            this->nodes.data[i0].extraNodeData_2.brigadier_float.max = dec_bef32(src);
          }
        } else if (!strcmp(this->nodes.data[i0].extraNodeData_2.parser, "brigadier:integer")) {
          uint8_t flags_ = dec_byte(src);
          this->nodes.data[i0].extraNodeData_2.brigadier_integer.flags.max_present = (flags_ >> 1) & 1;
          this->nodes.data[i0].extraNodeData_2.brigadier_integer.flags.min_present = (flags_) & 1;
          if (this->nodes.data[i0].extraNodeData_2.brigadier_integer.flags.min_present == 1) {
            this->nodes.data[i0].extraNodeData_2.brigadier_integer.min = dec_be32(src);
          }
          if (this->nodes.data[i0].extraNodeData_2.brigadier_integer.flags.max_present == 1) {
            this->nodes.data[i0].extraNodeData_2.brigadier_integer.max = dec_be32(src);
          }
        } else if (!strcmp(this->nodes.data[i0].extraNodeData_2.parser, "brigadier:string")) {
          this->nodes.data[i0].extraNodeData_2.brigadier_string = dec_varint(src);
        } else if (!strcmp(this->nodes.data[i0].extraNodeData_2.parser, "minecraft:entity")) {
          this->nodes.data[i0].extraNodeData_2.minecraft_entity = dec_byte(src);
        } else if (!strcmp(this->nodes.data[i0].extraNodeData_2.parser, "minecraft:score_holder")) {
          this->nodes.data[i0].extraNodeData_2.minecraft_score_holder = dec_byte(src);
        }
        if (this->nodes.data[i0].flags.has_custom_suggestions == 1) {
          this->nodes.data[i0].extraNodeData_2.suggests = dec_string(src);
        }
        break;
    }
  }
  this->rootIndex = dec_varint(src);
}

void ClientboundTransaction_encode(FILE* dest, ClientboundTransaction* this) {
  enc_byte(dest, this->windowId);
  enc_be16(dest, this->action);
  enc_byte(dest, this->accepted);
}
void ClientboundTransaction_decode(FILE* src, ClientboundTransaction* this) {
  this->windowId = dec_byte(src);
  this->action = dec_be16(src);
  this->accepted = dec_byte(src);
}

void ClientboundCloseWindow_encode(FILE* dest, ClientboundCloseWindow* this) {
  enc_byte(dest, this->windowId);
}
void ClientboundCloseWindow_decode(FILE* src, ClientboundCloseWindow* this) {
  this->windowId = dec_byte(src);
}

void ClientboundWindowItems_encode(FILE* dest, ClientboundWindowItems* this) {
  enc_byte(dest, this->windowId);
  enc_be16(dest, this->items.size);
  for (int i0 = 0; i0 < this->items.size; i0++) {
    mc_slot_encode(dest, &this->items.data[i0]);
  }
}
void ClientboundWindowItems_decode(FILE* src, ClientboundWindowItems* this) {
  this->windowId = dec_byte(src);
  this->items.size = dec_be16(src);
  this->items.data = (mc_slot*) malloc(this->items.size * sizeof(mc_slot));
  for (int i0 = 0; i0 < this->items.size; i0++) {
    mc_slot_decode(src, &this->items.data[i0]);
  }
}

void ClientboundCraftProgressBar_encode(FILE* dest, ClientboundCraftProgressBar* this) {
  enc_byte(dest, this->windowId);
  enc_be16(dest, this->property);
  enc_be16(dest, this->value);
}
void ClientboundCraftProgressBar_decode(FILE* src, ClientboundCraftProgressBar* this) {
  this->windowId = dec_byte(src);
  this->property = dec_be16(src);
  this->value = dec_be16(src);
}

void ClientboundSetSlot_encode(FILE* dest, ClientboundSetSlot* this) {
  enc_byte(dest, this->windowId);
  enc_be16(dest, this->slot);
  mc_slot_encode(dest, &this->item);
}
void ClientboundSetSlot_decode(FILE* src, ClientboundSetSlot* this) {
  this->windowId = dec_byte(src);
  this->slot = dec_be16(src);
  mc_slot_decode(src, &this->item);
}

void ClientboundSetCooldown_encode(FILE* dest, ClientboundSetCooldown* this) {
  enc_varint(dest, this->itemID);
  enc_varint(dest, this->cooldownTicks);
}
void ClientboundSetCooldown_decode(FILE* src, ClientboundSetCooldown* this) {
  this->itemID = dec_varint(src);
  this->cooldownTicks = dec_varint(src);
}

void ClientboundCustomPayload_encode(FILE* dest, ClientboundCustomPayload* this) {
  enc_string(dest, this->channel);
  fwrite(this->data.data, sizeof(char), this->data.size, dest);
}
void ClientboundCustomPayload_decode(FILE* src, ClientboundCustomPayload* this) {
  this->channel = dec_string(src);
  this->data.size = 0; /* todo */
}

void ClientboundNamedSoundEffect_encode(FILE* dest, ClientboundNamedSoundEffect* this) {
  enc_string(dest, this->soundName);
  enc_varint(dest, this->soundCategory);
  enc_be32(dest, this->x);
  enc_be32(dest, this->y);
  enc_be32(dest, this->z);
  enc_bef32(dest, this->volume);
  enc_bef32(dest, this->pitch);
}
void ClientboundNamedSoundEffect_decode(FILE* src, ClientboundNamedSoundEffect* this) {
  this->soundName = dec_string(src);
  this->soundCategory = dec_varint(src);
  this->x = dec_be32(src);
  this->y = dec_be32(src);
  this->z = dec_be32(src);
  this->volume = dec_bef32(src);
  this->pitch = dec_bef32(src);
}

void ClientboundKickDisconnect_encode(FILE* dest, ClientboundKickDisconnect* this) {
  enc_string(dest, this->reason);
}
void ClientboundKickDisconnect_decode(FILE* src, ClientboundKickDisconnect* this) {
  this->reason = dec_string(src);
}

void ClientboundEntityStatus_encode(FILE* dest, ClientboundEntityStatus* this) {
  enc_be32(dest, this->entityId);
  enc_byte(dest, this->entityStatus);
}
void ClientboundEntityStatus_decode(FILE* src, ClientboundEntityStatus* this) {
  this->entityId = dec_be32(src);
  this->entityStatus = dec_byte(src);
}

void ClientboundExplosion_encode(FILE* dest, ClientboundExplosion* this) {
  enc_bef32(dest, this->x);
  enc_bef32(dest, this->y);
  enc_bef32(dest, this->z);
  enc_bef32(dest, this->radius);
  enc_be32(dest, this->affectedBlockOffsets.size);
  for (int i0 = 0; i0 < this->affectedBlockOffsets.size; i0++) {
    enc_byte(dest, this->affectedBlockOffsets.data[i0].x);
    enc_byte(dest, this->affectedBlockOffsets.data[i0].y);
    enc_byte(dest, this->affectedBlockOffsets.data[i0].z);
  }
  enc_bef32(dest, this->playerMotionX);
  enc_bef32(dest, this->playerMotionY);
  enc_bef32(dest, this->playerMotionZ);
}
void ClientboundExplosion_decode(FILE* src, ClientboundExplosion* this) {
  this->x = dec_bef32(src);
  this->y = dec_bef32(src);
  this->z = dec_bef32(src);
  this->radius = dec_bef32(src);
  this->affectedBlockOffsets.size = dec_be32(src);
  this->affectedBlockOffsets.data = (Explosion_affectedBlockOffsets_type*) malloc(this->affectedBlockOffsets.size * sizeof(Explosion_affectedBlockOffsets_type));
  for (int i0 = 0; i0 < this->affectedBlockOffsets.size; i0++) {
    this->affectedBlockOffsets.data[i0].x = dec_byte(src);
    this->affectedBlockOffsets.data[i0].y = dec_byte(src);
    this->affectedBlockOffsets.data[i0].z = dec_byte(src);
  }
  this->playerMotionX = dec_bef32(src);
  this->playerMotionY = dec_bef32(src);
  this->playerMotionZ = dec_bef32(src);
}

void ClientboundUnloadChunk_encode(FILE* dest, ClientboundUnloadChunk* this) {
  enc_be32(dest, this->chunkX);
  enc_be32(dest, this->chunkZ);
}
void ClientboundUnloadChunk_decode(FILE* src, ClientboundUnloadChunk* this) {
  this->chunkX = dec_be32(src);
  this->chunkZ = dec_be32(src);
}

void ClientboundGameStateChange_encode(FILE* dest, ClientboundGameStateChange* this) {
  enc_byte(dest, this->reason);
  enc_bef32(dest, this->gameMode);
}
void ClientboundGameStateChange_decode(FILE* src, ClientboundGameStateChange* this) {
  this->reason = dec_byte(src);
  this->gameMode = dec_bef32(src);
}

void ClientboundOpenHorseWindow_encode(FILE* dest, ClientboundOpenHorseWindow* this) {
  enc_byte(dest, this->windowId);
  enc_varint(dest, this->nbSlots);
  enc_be32(dest, this->entityId);
}
void ClientboundOpenHorseWindow_decode(FILE* src, ClientboundOpenHorseWindow* this) {
  this->windowId = dec_byte(src);
  this->nbSlots = dec_varint(src);
  this->entityId = dec_be32(src);
}

void ClientboundKeepAlive_encode(FILE* dest, ClientboundKeepAlive* this) {
  enc_be64(dest, this->keepAliveId);
}
void ClientboundKeepAlive_decode(FILE* src, ClientboundKeepAlive* this) {
  this->keepAliveId = dec_be64(src);
}

void ClientboundMapChunk_encode(FILE* dest, ClientboundMapChunk* this) {
  enc_be32(dest, this->x);
  enc_be32(dest, this->z);
  enc_byte(dest, this->groundUp);
  enc_byte(dest, this->ignoreOldData);
  enc_varint(dest, this->bitMap);
  encode_full(dest, this->heightmaps);
  if (this->groundUp) {
    for (int i1 = 0; i1 < this->biomes.size; i1++) {
      enc_be32(dest, this->biomes.data[i1]);
    }
  }
  enc_varint(dest, this->chunkData.size);
  enc_buffer(dest, this->chunkData);
  enc_varint(dest, this->blockEntities.size);
  for (int i0 = 0; i0 < this->blockEntities.size; i0++) {
    encode_full(dest, this->blockEntities.data[i0]);
  }
}
void ClientboundMapChunk_decode(FILE* src, ClientboundMapChunk* this) {
  this->x = dec_be32(src);
  this->z = dec_be32(src);
  this->groundUp = dec_byte(src);
  this->ignoreOldData = dec_byte(src);
  this->bitMap = dec_varint(src);
  decode_full(src, this->heightmaps);
  if (this->groundUp) {
    for (int i1 = 0; i1 < this->biomes.size; i1++) {
      this->biomes.data[i1] = dec_be32(src);
    }
  }
  this->chunkData = dec_buffer(src, dec_varint(src));
  this->blockEntities.size = dec_varint(src);
  this->blockEntities.data = (nbt_tag_compound*) malloc(this->blockEntities.size * sizeof(nbt_tag_compound));
  for (int i0 = 0; i0 < this->blockEntities.size; i0++) {
    decode_full(src, this->blockEntities.data[i0]);
  }
}

void ClientboundWorldEvent_encode(FILE* dest, ClientboundWorldEvent* this) {
  enc_be32(dest, this->effectId);
  enc_position(dest, this->location);
  enc_be32(dest, this->data);
  enc_byte(dest, this->global);
}
void ClientboundWorldEvent_decode(FILE* src, ClientboundWorldEvent* this) {
  this->effectId = dec_be32(src);
  this->location = dec_position(src);
  this->data = dec_be32(src);
  this->global = dec_byte(src);
}

void ClientboundWorldParticles_encode(FILE* dest, ClientboundWorldParticles* this) {
  enc_be32(dest, this->particleId);
  enc_byte(dest, this->longDistance);
  enc_bef64(dest, this->x);
  enc_bef64(dest, this->y);
  enc_bef64(dest, this->z);
  enc_bef32(dest, this->offsetX);
  enc_bef32(dest, this->offsetY);
  enc_bef32(dest, this->offsetZ);
  enc_bef32(dest, this->particleData);
  enc_be32(dest, this->particles);
  mc_particle_encode(dest, &this->data);
}
void ClientboundWorldParticles_decode(FILE* src, ClientboundWorldParticles* this) {
  this->particleId = dec_be32(src);
  this->longDistance = dec_byte(src);
  this->x = dec_bef64(src);
  this->y = dec_bef64(src);
  this->z = dec_bef64(src);
  this->offsetX = dec_bef32(src);
  this->offsetY = dec_bef32(src);
  this->offsetZ = dec_bef32(src);
  this->particleData = dec_bef32(src);
  this->particles = dec_be32(src);
  mc_particle_decode(src, &this->data, (mc_particle_type) this->particleId);
}

void ClientboundUpdateLight_encode(FILE* dest, ClientboundUpdateLight* this) {
  enc_varint(dest, this->chunkX);
  enc_varint(dest, this->chunkZ);
  enc_byte(dest, this->trustEdges);
  enc_varint(dest, this->skyLightMask);
  enc_varint(dest, this->blockLightMask);
  enc_varint(dest, this->emptySkyLightMask);
  enc_varint(dest, this->emptyBlockLightMask);
  fwrite(this->data.data, sizeof(char), this->data.size, dest);
}
void ClientboundUpdateLight_decode(FILE* src, ClientboundUpdateLight* this) {
  this->chunkX = dec_varint(src);
  this->chunkZ = dec_varint(src);
  this->trustEdges = dec_byte(src);
  this->skyLightMask = dec_varint(src);
  this->blockLightMask = dec_varint(src);
  this->emptySkyLightMask = dec_varint(src);
  this->emptyBlockLightMask = dec_varint(src);
  this->data.size = 0; /* todo */
}

void ClientboundLogin_encode(FILE* dest, ClientboundLogin* this) {
  enc_be32(dest, this->entityId);
  enc_byte(dest, this->gameMode);
  enc_byte(dest, this->previousGameMode);
  enc_varint(dest, this->worldNames.size);
  for (int i0 = 0; i0 < this->worldNames.size; i0++) {
    enc_string(dest, this->worldNames.data[i0]);
  }
  encode_full(dest, this->dimensionCodec);
  enc_string(dest, this->dimension);
  enc_string(dest, this->worldName);
  enc_be64(dest, this->hashedSeed);
  enc_byte(dest, this->maxPlayers);
  enc_varint(dest, this->viewDistance);
  enc_byte(dest, this->reducedDebugInfo);
  enc_byte(dest, this->enableRespawnScreen);
  enc_byte(dest, this->isDebug);
  enc_byte(dest, this->isFlat);
}
void ClientboundLogin_decode(FILE* src, ClientboundLogin* this) {
  this->entityId = dec_be32(src);
  this->gameMode = dec_byte(src);
  this->previousGameMode = dec_byte(src);
  this->worldNames.size = dec_varint(src);
  this->worldNames.data = (string_t*) malloc(this->worldNames.size * sizeof(string_t));
  for (int i0 = 0; i0 < this->worldNames.size; i0++) {
    this->worldNames.data[i0] = dec_string(src);
  }
  decode_full(src, this->dimensionCodec);
  this->dimension = dec_string(src);
  this->worldName = dec_string(src);
  this->hashedSeed = dec_be64(src);
  this->maxPlayers = dec_byte(src);
  this->viewDistance = dec_varint(src);
  this->reducedDebugInfo = dec_byte(src);
  this->enableRespawnScreen = dec_byte(src);
  this->isDebug = dec_byte(src);
  this->isFlat = dec_byte(src);
}

void ClientboundMap_encode(FILE* dest, ClientboundMap* this) {
  enc_varint(dest, this->itemDamage);
  enc_byte(dest, this->scale);
  enc_byte(dest, this->trackingPosition);
  enc_byte(dest, this->locked);
  enc_varint(dest, this->icons.size);
  for (int i0 = 0; i0 < this->icons.size; i0++) {
    enc_varint(dest, this->icons.data[i0].type);
    enc_byte(dest, this->icons.data[i0].x);
    enc_byte(dest, this->icons.data[i0].y);
    enc_byte(dest, this->icons.data[i0].direction);
    enc_byte(dest, this->icons.data[i0].displayName.has_value);
    if (this->icons.data[i0].displayName.has_value) {
      enc_string(dest, this->icons.data[i0].displayName.value);
    }
  }
  enc_byte(dest, this->columns);
  if (this->columns != 0) {
    enc_byte(dest, this->rows);
    enc_byte(dest, this->x);
    enc_byte(dest, this->y);
    enc_varint(dest, this->data.size);
    enc_buffer(dest, this->data);
  }
}
void ClientboundMap_decode(FILE* src, ClientboundMap* this) {
  this->itemDamage = dec_varint(src);
  this->scale = dec_byte(src);
  this->trackingPosition = dec_byte(src);
  this->locked = dec_byte(src);
  this->icons.size = dec_varint(src);
  this->icons.data = (Map_icons_type*) malloc(this->icons.size * sizeof(Map_icons_type));
  for (int i0 = 0; i0 < this->icons.size; i0++) {
    this->icons.data[i0].type = dec_varint(src);
    this->icons.data[i0].x = dec_byte(src);
    this->icons.data[i0].y = dec_byte(src);
    this->icons.data[i0].direction = dec_byte(src);
    if (dec_byte(src)) {
      this->icons.data[i0].displayName.has_value = true;
      this->icons.data[i0].displayName.value = dec_string(src);
    }
  }
  this->columns = dec_byte(src);
  if (this->columns != 0) {
    this->rows = dec_byte(src);
    this->x = dec_byte(src);
    this->y = dec_byte(src);
    this->data = dec_buffer(src, dec_varint(src));
  }
}

void ClientboundTradeList_encode(FILE* dest, ClientboundTradeList* this) {
  enc_varint(dest, this->windowId);
  enc_byte(dest, this->trades.size);
  for (int i0 = 0; i0 < this->trades.size; i0++) {
    mc_slot_encode(dest, &this->trades.data[i0].inputItem1);
    mc_slot_encode(dest, &this->trades.data[i0].outputItem);
    enc_byte(dest, this->trades.data[i0].inputItem2.has_value);
    if (this->trades.data[i0].inputItem2.has_value) {
      mc_slot_encode(dest, &this->trades.data[i0].inputItem2.value);
    }
    enc_byte(dest, this->trades.data[i0].tradeDisabled);
    enc_be32(dest, this->trades.data[i0].nbTradeUses);
    enc_be32(dest, this->trades.data[i0].maximumNbTradeUses);
    enc_be32(dest, this->trades.data[i0].xp);
    enc_be32(dest, this->trades.data[i0].specialPrice);
    enc_bef32(dest, this->trades.data[i0].priceMultiplier);
    enc_be32(dest, this->trades.data[i0].demand);
  }
  enc_varint(dest, this->villagerLevel);
  enc_varint(dest, this->experience);
  enc_byte(dest, this->isRegularVillager);
  enc_byte(dest, this->canRestock);
}
void ClientboundTradeList_decode(FILE* src, ClientboundTradeList* this) {
  this->windowId = dec_varint(src);
  this->trades.size = dec_byte(src);
  this->trades.data = (TradeList_trades_type*) malloc(this->trades.size * sizeof(TradeList_trades_type));
  for (int i0 = 0; i0 < this->trades.size; i0++) {
    mc_slot_decode(src, &this->trades.data[i0].inputItem1);
    mc_slot_decode(src, &this->trades.data[i0].outputItem);
    if (dec_byte(src)) {
      this->trades.data[i0].inputItem2.has_value = true;
      mc_slot_decode(src, &this->trades.data[i0].inputItem2.value);
    }
    this->trades.data[i0].tradeDisabled = dec_byte(src);
    this->trades.data[i0].nbTradeUses = dec_be32(src);
    this->trades.data[i0].maximumNbTradeUses = dec_be32(src);
    this->trades.data[i0].xp = dec_be32(src);
    this->trades.data[i0].specialPrice = dec_be32(src);
    this->trades.data[i0].priceMultiplier = dec_bef32(src);
    this->trades.data[i0].demand = dec_be32(src);
  }
  this->villagerLevel = dec_varint(src);
  this->experience = dec_varint(src);
  this->isRegularVillager = dec_byte(src);
  this->canRestock = dec_byte(src);
}

void ClientboundRelEntityMove_encode(FILE* dest, ClientboundRelEntityMove* this) {
  enc_varint(dest, this->entityId);
  enc_be16(dest, this->dX);
  enc_be16(dest, this->dY);
  enc_be16(dest, this->dZ);
  enc_byte(dest, this->onGround);
}
void ClientboundRelEntityMove_decode(FILE* src, ClientboundRelEntityMove* this) {
  this->entityId = dec_varint(src);
  this->dX = dec_be16(src);
  this->dY = dec_be16(src);
  this->dZ = dec_be16(src);
  this->onGround = dec_byte(src);
}

void ClientboundEntityMoveLook_encode(FILE* dest, ClientboundEntityMoveLook* this) {
  enc_varint(dest, this->entityId);
  enc_be16(dest, this->dX);
  enc_be16(dest, this->dY);
  enc_be16(dest, this->dZ);
  enc_byte(dest, this->yaw);
  enc_byte(dest, this->pitch);
  enc_byte(dest, this->onGround);
}
void ClientboundEntityMoveLook_decode(FILE* src, ClientboundEntityMoveLook* this) {
  this->entityId = dec_varint(src);
  this->dX = dec_be16(src);
  this->dY = dec_be16(src);
  this->dZ = dec_be16(src);
  this->yaw = dec_byte(src);
  this->pitch = dec_byte(src);
  this->onGround = dec_byte(src);
}

void ClientboundEntityLook_encode(FILE* dest, ClientboundEntityLook* this) {
  enc_varint(dest, this->entityId);
  enc_byte(dest, this->yaw);
  enc_byte(dest, this->pitch);
  enc_byte(dest, this->onGround);
}
void ClientboundEntityLook_decode(FILE* src, ClientboundEntityLook* this) {
  this->entityId = dec_varint(src);
  this->yaw = dec_byte(src);
  this->pitch = dec_byte(src);
  this->onGround = dec_byte(src);
}

void ClientboundEntity_encode(FILE* dest, ClientboundEntity* this) {
  enc_varint(dest, this->entityId);
}
void ClientboundEntity_decode(FILE* src, ClientboundEntity* this) {
  this->entityId = dec_varint(src);
}

void ClientboundVehicleMove_encode(FILE* dest, ClientboundVehicleMove* this) {
  enc_bef64(dest, this->x);
  enc_bef64(dest, this->y);
  enc_bef64(dest, this->z);
  enc_bef32(dest, this->yaw);
  enc_bef32(dest, this->pitch);
}
void ClientboundVehicleMove_decode(FILE* src, ClientboundVehicleMove* this) {
  this->x = dec_bef64(src);
  this->y = dec_bef64(src);
  this->z = dec_bef64(src);
  this->yaw = dec_bef32(src);
  this->pitch = dec_bef32(src);
}

void ClientboundOpenBook_encode(FILE* dest, ClientboundOpenBook* this) {
  enc_varint(dest, this->hand);
}
void ClientboundOpenBook_decode(FILE* src, ClientboundOpenBook* this) {
  this->hand = dec_varint(src);
}

void ClientboundOpenWindow_encode(FILE* dest, ClientboundOpenWindow* this) {
  enc_varint(dest, this->windowId);
  enc_varint(dest, this->inventoryType);
  enc_string(dest, this->windowTitle);
}
void ClientboundOpenWindow_decode(FILE* src, ClientboundOpenWindow* this) {
  this->windowId = dec_varint(src);
  this->inventoryType = dec_varint(src);
  this->windowTitle = dec_string(src);
}

void ClientboundOpenSignEntity_encode(FILE* dest, ClientboundOpenSignEntity* this) {
  enc_position(dest, this->location);
}
void ClientboundOpenSignEntity_decode(FILE* src, ClientboundOpenSignEntity* this) {
  this->location = dec_position(src);
}

void ClientboundCraftRecipeResponse_encode(FILE* dest, ClientboundCraftRecipeResponse* this) {
  enc_byte(dest, this->windowId);
  enc_string(dest, this->recipe);
}
void ClientboundCraftRecipeResponse_decode(FILE* src, ClientboundCraftRecipeResponse* this) {
  this->windowId = dec_byte(src);
  this->recipe = dec_string(src);
}

void ClientboundAbilities_encode(FILE* dest, ClientboundAbilities* this) {
  enc_byte(dest, this->flags);
  enc_bef32(dest, this->flyingSpeed);
  enc_bef32(dest, this->walkingSpeed);
}
void ClientboundAbilities_decode(FILE* src, ClientboundAbilities* this) {
  this->flags = dec_byte(src);
  this->flyingSpeed = dec_bef32(src);
  this->walkingSpeed = dec_bef32(src);
}

void ClientboundCombatEvent_encode(FILE* dest, ClientboundCombatEvent* this) {
  enc_varint(dest, this->event);
  switch (this->event) {
    case 1:
      enc_varint(dest, this->duration);
      enc_be32(dest, this->entityId);
      break;
    case 2:
      enc_varint(dest, this->playerId);
      enc_be32(dest, this->entityId);
      enc_string(dest, this->message);
      break;
  }
}
void ClientboundCombatEvent_decode(FILE* src, ClientboundCombatEvent* this) {
  this->event = dec_varint(src);
  switch (this->event) {
    case 1:
      this->duration = dec_varint(src);
      this->entityId = dec_be32(src);
      break;
    case 2:
      this->playerId = dec_varint(src);
      this->entityId = dec_be32(src);
      this->message = dec_string(src);
      break;
  }
}

void ClientboundPlayerInfo_encode(FILE* dest, ClientboundPlayerInfo* this) {
  enc_varint(dest, this->action);
  enc_varint(dest, this->data.size);
  for (int i0 = 0; i0 < this->data.size; i0++) {
    enc_uuid(dest, this->data.data[i0].UUID);
    switch (this->action) {
      case 0:
        enc_string(dest, this->data.data[i0].name);
        enc_varint(dest, this->data.data[i0].properties.size);
        for (int i3 = 0; i3 < this->data.data[i0].properties.size; i3++) {
          enc_string(dest, this->data.data[i0].properties.data[i3].name);
          enc_string(dest, this->data.data[i0].properties.data[i3].value);
          enc_byte(dest, this->data.data[i0].properties.data[i3].signature.has_value);
          if (this->data.data[i0].properties.data[i3].signature.has_value) {
            enc_string(dest, this->data.data[i0].properties.data[i3].signature.value);
          }
        }
        enc_varint(dest, this->data.data[i0].gamemode);
        enc_varint(dest, this->data.data[i0].ping);
        enc_byte(dest, this->data.data[i0].displayName.has_value);
        if (this->data.data[i0].displayName.has_value) {
          enc_string(dest, this->data.data[i0].displayName.value);
        }
        break;
      case 1:
        enc_varint(dest, this->data.data[i0].gamemode);
        break;
      case 2:
        enc_varint(dest, this->data.data[i0].ping);
        break;
      case 3:
        enc_byte(dest, this->data.data[i0].displayName.has_value);
        if (this->data.data[i0].displayName.has_value) {
          enc_string(dest, this->data.data[i0].displayName.value);
        }
        break;
    }
  }
}
void ClientboundPlayerInfo_decode(FILE* src, ClientboundPlayerInfo* this) {
  this->action = dec_varint(src);
  this->data.size = dec_varint(src);
  this->data.data = (PlayerInfo_data_type*) malloc(this->data.size * sizeof(PlayerInfo_data_type));
  for (int i0 = 0; i0 < this->data.size; i0++) {
    this->data.data[i0].UUID = dec_uuid(src);
    switch (this->action) {
      case 0:
        this->data.data[i0].name = dec_string(src);
        this->data.data[i0].properties.size = dec_varint(src);
        this->data.data[i0].properties.data = (PlayerInfo_properties_type*) malloc(this->data.data[i0].properties.size * sizeof(PlayerInfo_properties_type));
        for (int i3 = 0; i3 < this->data.data[i0].properties.size; i3++) {
          this->data.data[i0].properties.data[i3].name = dec_string(src);
          this->data.data[i0].properties.data[i3].value = dec_string(src);
          if (dec_byte(src)) {
            this->data.data[i0].properties.data[i3].signature.has_value = true;
            this->data.data[i0].properties.data[i3].signature.value = dec_string(src);
          }
        }
        this->data.data[i0].gamemode = dec_varint(src);
        this->data.data[i0].ping = dec_varint(src);
        if (dec_byte(src)) {
          this->data.data[i0].displayName.has_value = true;
          this->data.data[i0].displayName.value = dec_string(src);
        }
        break;
      case 1:
        this->data.data[i0].gamemode = dec_varint(src);
        break;
      case 2:
        this->data.data[i0].ping = dec_varint(src);
        break;
      case 3:
        if (dec_byte(src)) {
          this->data.data[i0].displayName.has_value = true;
          this->data.data[i0].displayName.value = dec_string(src);
        }
        break;
    }
  }
}

void ClientboundFacePlayer_encode(FILE* dest, ClientboundFacePlayer* this) {
  enc_varint(dest, this->feet_eyes);
  enc_bef64(dest, this->x);
  enc_bef64(dest, this->y);
  enc_bef64(dest, this->z);
  enc_byte(dest, this->isEntity);
  if (this->isEntity) {
    enc_varint(dest, this->entityId);
    enc_string(dest, this->entity_feet_eyes);
  }
}
void ClientboundFacePlayer_decode(FILE* src, ClientboundFacePlayer* this) {
  this->feet_eyes = dec_varint(src);
  this->x = dec_bef64(src);
  this->y = dec_bef64(src);
  this->z = dec_bef64(src);
  this->isEntity = dec_byte(src);
  if (this->isEntity) {
    this->entityId = dec_varint(src);
    this->entity_feet_eyes = dec_string(src);
  }
}

void ClientboundPosition_encode(FILE* dest, ClientboundPosition* this) {
  enc_bef64(dest, this->x);
  enc_bef64(dest, this->y);
  enc_bef64(dest, this->z);
  enc_bef32(dest, this->yaw);
  enc_bef32(dest, this->pitch);
  enc_byte(dest, this->flags);
  enc_varint(dest, this->teleportId);
}
void ClientboundPosition_decode(FILE* src, ClientboundPosition* this) {
  this->x = dec_bef64(src);
  this->y = dec_bef64(src);
  this->z = dec_bef64(src);
  this->yaw = dec_bef32(src);
  this->pitch = dec_bef32(src);
  this->flags = dec_byte(src);
  this->teleportId = dec_varint(src);
}

void ClientboundUnlockRecipes_encode(FILE* dest, ClientboundUnlockRecipes* this) {
  enc_varint(dest, this->action);
  enc_byte(dest, this->craftingBookOpen);
  enc_byte(dest, this->filteringCraftable);
  enc_byte(dest, this->smeltingBookOpen);
  enc_byte(dest, this->filteringSmeltable);
  enc_varint(dest, this->recipes1.size);
  for (int i0 = 0; i0 < this->recipes1.size; i0++) {
    enc_string(dest, this->recipes1.data[i0]);
  }
  if (this->action == 0) {
    enc_varint(dest, this->recipes2.size);
    for (int i1 = 0; i1 < this->recipes2.size; i1++) {
      enc_string(dest, this->recipes2.data[i1]);
    }
  }
}
void ClientboundUnlockRecipes_decode(FILE* src, ClientboundUnlockRecipes* this) {
  this->action = dec_varint(src);
  this->craftingBookOpen = dec_byte(src);
  this->filteringCraftable = dec_byte(src);
  this->smeltingBookOpen = dec_byte(src);
  this->filteringSmeltable = dec_byte(src);
  this->recipes1.size = dec_varint(src);
  this->recipes1.data = (string_t*) malloc(this->recipes1.size * sizeof(string_t));
  for (int i0 = 0; i0 < this->recipes1.size; i0++) {
    this->recipes1.data[i0] = dec_string(src);
  }
  if (this->action == 0) {
    this->recipes2.size = dec_varint(src);
    this->recipes2.data = (string_t*) malloc(this->recipes2.size * sizeof(string_t));
    for (int i1 = 0; i1 < this->recipes2.size; i1++) {
      this->recipes2.data[i1] = dec_string(src);
    }
  }
}

void ClientboundEntityDestroy_encode(FILE* dest, ClientboundEntityDestroy* this) {
  enc_varint(dest, this->entityIds.size);
  for (int i0 = 0; i0 < this->entityIds.size; i0++) {
    enc_varint(dest, this->entityIds.data[i0]);
  }
}
void ClientboundEntityDestroy_decode(FILE* src, ClientboundEntityDestroy* this) {
  this->entityIds.size = dec_varint(src);
  this->entityIds.data = (int64_t*) malloc(this->entityIds.size * sizeof(int64_t));
  for (int i0 = 0; i0 < this->entityIds.size; i0++) {
    this->entityIds.data[i0] = dec_varint(src);
  }
}

void ClientboundRemoveEntityEffect_encode(FILE* dest, ClientboundRemoveEntityEffect* this) {
  enc_varint(dest, this->entityId);
  enc_byte(dest, this->effectId);
}
void ClientboundRemoveEntityEffect_decode(FILE* src, ClientboundRemoveEntityEffect* this) {
  this->entityId = dec_varint(src);
  this->effectId = dec_byte(src);
}

void ClientboundResourcePackSend_encode(FILE* dest, ClientboundResourcePackSend* this) {
  enc_string(dest, this->url);
  enc_string(dest, this->hash);
}
void ClientboundResourcePackSend_decode(FILE* src, ClientboundResourcePackSend* this) {
  this->url = dec_string(src);
  this->hash = dec_string(src);
}

void ClientboundRespawn_encode(FILE* dest, ClientboundRespawn* this) {
  enc_string(dest, this->dimension);
  enc_string(dest, this->worldName);
  enc_be64(dest, this->hashedSeed);
  enc_byte(dest, this->gamemode);
  enc_byte(dest, this->previousGamemode);
  enc_byte(dest, this->isDebug);
  enc_byte(dest, this->isFlat);
  enc_byte(dest, this->copyMetadata);
}
void ClientboundRespawn_decode(FILE* src, ClientboundRespawn* this) {
  this->dimension = dec_string(src);
  this->worldName = dec_string(src);
  this->hashedSeed = dec_be64(src);
  this->gamemode = dec_byte(src);
  this->previousGamemode = dec_byte(src);
  this->isDebug = dec_byte(src);
  this->isFlat = dec_byte(src);
  this->copyMetadata = dec_byte(src);
}

void ClientboundEntityHeadRotation_encode(FILE* dest, ClientboundEntityHeadRotation* this) {
  enc_varint(dest, this->entityId);
  enc_byte(dest, this->headYaw);
}
void ClientboundEntityHeadRotation_decode(FILE* src, ClientboundEntityHeadRotation* this) {
  this->entityId = dec_varint(src);
  this->headYaw = dec_byte(src);
}

void ClientboundSelectAdvancementTab_encode(FILE* dest, ClientboundSelectAdvancementTab* this) {
  enc_byte(dest, this->id.has_value);
  if (this->id.has_value) {
    enc_string(dest, this->id.value);
  }
}
void ClientboundSelectAdvancementTab_decode(FILE* src, ClientboundSelectAdvancementTab* this) {
  if (dec_byte(src)) {
    this->id.has_value = true;
    this->id.value = dec_string(src);
  }
}

void ClientboundWorldBorder_encode(FILE* dest, ClientboundWorldBorder* this) {
  enc_varint(dest, this->action);
  switch (this->action) {
    case 0:
      enc_bef64(dest, this->radius);
      break;
    case 1:
      enc_bef64(dest, this->old_radius);
      enc_bef64(dest, this->new_radius);
      enc_varint(dest, this->speed);
      break;
    case 2:
      enc_bef64(dest, this->x);
      enc_bef64(dest, this->z);
      break;
    case 3:
      enc_bef64(dest, this->x);
      enc_bef64(dest, this->z);
      enc_bef64(dest, this->old_radius);
      enc_bef64(dest, this->new_radius);
      enc_varint(dest, this->speed);
      enc_varint(dest, this->portalBoundary);
      enc_varint(dest, this->warning_time);
      enc_varint(dest, this->warning_blocks);
      break;
    case 4:
      enc_varint(dest, this->warning_time);
      break;
    case 5:
      enc_varint(dest, this->warning_blocks);
      break;
  }
}
void ClientboundWorldBorder_decode(FILE* src, ClientboundWorldBorder* this) {
  this->action = dec_varint(src);
  switch (this->action) {
    case 0:
      this->radius = dec_bef64(src);
      break;
    case 1:
      this->old_radius = dec_bef64(src);
      this->new_radius = dec_bef64(src);
      this->speed = dec_varint(src);
      break;
    case 2:
      this->x = dec_bef64(src);
      this->z = dec_bef64(src);
      break;
    case 3:
      this->x = dec_bef64(src);
      this->z = dec_bef64(src);
      this->old_radius = dec_bef64(src);
      this->new_radius = dec_bef64(src);
      this->speed = dec_varint(src);
      this->portalBoundary = dec_varint(src);
      this->warning_time = dec_varint(src);
      this->warning_blocks = dec_varint(src);
      break;
    case 4:
      this->warning_time = dec_varint(src);
      break;
    case 5:
      this->warning_blocks = dec_varint(src);
      break;
  }
}

void ClientboundCamera_encode(FILE* dest, ClientboundCamera* this) {
  enc_varint(dest, this->cameraId);
}
void ClientboundCamera_decode(FILE* src, ClientboundCamera* this) {
  this->cameraId = dec_varint(src);
}

void ClientboundHeldItemSlot_encode(FILE* dest, ClientboundHeldItemSlot* this) {
  enc_byte(dest, this->slot);
}
void ClientboundHeldItemSlot_decode(FILE* src, ClientboundHeldItemSlot* this) {
  this->slot = dec_byte(src);
}

void ClientboundUpdateViewPosition_encode(FILE* dest, ClientboundUpdateViewPosition* this) {
  enc_varint(dest, this->chunkX);
  enc_varint(dest, this->chunkZ);
}
void ClientboundUpdateViewPosition_decode(FILE* src, ClientboundUpdateViewPosition* this) {
  this->chunkX = dec_varint(src);
  this->chunkZ = dec_varint(src);
}

void ClientboundUpdateViewDistance_encode(FILE* dest, ClientboundUpdateViewDistance* this) {
  enc_varint(dest, this->viewDistance);
}
void ClientboundUpdateViewDistance_decode(FILE* src, ClientboundUpdateViewDistance* this) {
  this->viewDistance = dec_varint(src);
}

void ClientboundSpawnPosition_encode(FILE* dest, ClientboundSpawnPosition* this) {
  enc_position(dest, this->location);
}
void ClientboundSpawnPosition_decode(FILE* src, ClientboundSpawnPosition* this) {
  this->location = dec_position(src);
}

void ClientboundScoreboardDisplayObjective_encode(FILE* dest, ClientboundScoreboardDisplayObjective* this) {
  enc_byte(dest, this->position);
  enc_string(dest, this->name);
}
void ClientboundScoreboardDisplayObjective_decode(FILE* src, ClientboundScoreboardDisplayObjective* this) {
  this->position = dec_byte(src);
  this->name = dec_string(src);
}

void ClientboundEntityMetadata_encode(FILE* dest, ClientboundEntityMetadata* this) {
  enc_varint(dest, this->entityId);
  mc_entity_metadata_encode(dest, &this->metadata);
}
void ClientboundEntityMetadata_decode(FILE* src, ClientboundEntityMetadata* this) {
  this->entityId = dec_varint(src);
  mc_entity_metadata_decode(src, &this->metadata);
}

void ClientboundAttachEntity_encode(FILE* dest, ClientboundAttachEntity* this) {
  enc_be32(dest, this->entityId);
  enc_be32(dest, this->vehicleId);
}
void ClientboundAttachEntity_decode(FILE* src, ClientboundAttachEntity* this) {
  this->entityId = dec_be32(src);
  this->vehicleId = dec_be32(src);
}

void ClientboundEntityVelocity_encode(FILE* dest, ClientboundEntityVelocity* this) {
  enc_varint(dest, this->entityId);
  enc_be16(dest, this->velocityX);
  enc_be16(dest, this->velocityY);
  enc_be16(dest, this->velocityZ);
}
void ClientboundEntityVelocity_decode(FILE* src, ClientboundEntityVelocity* this) {
  this->entityId = dec_varint(src);
  this->velocityX = dec_be16(src);
  this->velocityY = dec_be16(src);
  this->velocityZ = dec_be16(src);
}

void ClientboundEntityEquipment_encode(FILE* dest, ClientboundEntityEquipment* this) {
  enc_varint(dest, this->entityId);
  mc_entity_equipment_encode(dest, &this->equipments);
}
void ClientboundEntityEquipment_decode(FILE* src, ClientboundEntityEquipment* this) {
  this->entityId = dec_varint(src);
  mc_entity_equipment_decode(src, &this->equipments);
}

void ClientboundExperience_encode(FILE* dest, ClientboundExperience* this) {
  enc_bef32(dest, this->experienceBar);
  enc_varint(dest, this->level);
  enc_varint(dest, this->totalExperience);
}
void ClientboundExperience_decode(FILE* src, ClientboundExperience* this) {
  this->experienceBar = dec_bef32(src);
  this->level = dec_varint(src);
  this->totalExperience = dec_varint(src);
}

void ClientboundUpdateHealth_encode(FILE* dest, ClientboundUpdateHealth* this) {
  enc_bef32(dest, this->health);
  enc_varint(dest, this->food);
  enc_bef32(dest, this->foodSaturation);
}
void ClientboundUpdateHealth_decode(FILE* src, ClientboundUpdateHealth* this) {
  this->health = dec_bef32(src);
  this->food = dec_varint(src);
  this->foodSaturation = dec_bef32(src);
}

void ClientboundScoreboardObjective_encode(FILE* dest, ClientboundScoreboardObjective* this) {
  enc_string(dest, this->name);
  enc_byte(dest, this->action);
  switch (this->action) {
    case 0:
      enc_string(dest, this->displayText);
      enc_varint(dest, this->type);
      break;
    case 2:
      enc_string(dest, this->displayText);
      enc_varint(dest, this->type);
      break;
  }
}
void ClientboundScoreboardObjective_decode(FILE* src, ClientboundScoreboardObjective* this) {
  this->name = dec_string(src);
  this->action = dec_byte(src);
  switch (this->action) {
    case 0:
      this->displayText = dec_string(src);
      this->type = dec_varint(src);
      break;
    case 2:
      this->displayText = dec_string(src);
      this->type = dec_varint(src);
      break;
  }
}

void ClientboundSetPassengers_encode(FILE* dest, ClientboundSetPassengers* this) {
  enc_varint(dest, this->entityId);
  enc_varint(dest, this->passengers.size);
  for (int i0 = 0; i0 < this->passengers.size; i0++) {
    enc_varint(dest, this->passengers.data[i0]);
  }
}
void ClientboundSetPassengers_decode(FILE* src, ClientboundSetPassengers* this) {
  this->entityId = dec_varint(src);
  this->passengers.size = dec_varint(src);
  this->passengers.data = (int64_t*) malloc(this->passengers.size * sizeof(int64_t));
  for (int i0 = 0; i0 < this->passengers.size; i0++) {
    this->passengers.data[i0] = dec_varint(src);
  }
}

void ClientboundTeams_encode(FILE* dest, ClientboundTeams* this) {
  enc_string(dest, this->team);
  enc_byte(dest, this->mode);
  switch (this->mode) {
    case 0:
      enc_string(dest, this->name);
      enc_byte(dest, this->friendlyFire);
      enc_string(dest, this->nameTagVisibility);
      enc_string(dest, this->collisionRule);
      enc_varint(dest, this->formatting);
      enc_string(dest, this->prefix);
      enc_string(dest, this->suffix);
      enc_varint(dest, this->players.size);
      for (int i1 = 0; i1 < this->players.size; i1++) {
        enc_string(dest, this->players.data[i1]);
      }
      break;
    case 2:
      enc_string(dest, this->name);
      enc_byte(dest, this->friendlyFire);
      enc_string(dest, this->nameTagVisibility);
      enc_string(dest, this->collisionRule);
      enc_varint(dest, this->formatting);
      enc_string(dest, this->prefix);
      enc_string(dest, this->suffix);
      break;
    case 3:
      enc_varint(dest, this->players.size);
      for (int i1 = 0; i1 < this->players.size; i1++) {
        enc_string(dest, this->players.data[i1]);
      }
      break;
    case 4:
      enc_varint(dest, this->players.size);
      for (int i1 = 0; i1 < this->players.size; i1++) {
        enc_string(dest, this->players.data[i1]);
      }
      break;
  }
}
void ClientboundTeams_decode(FILE* src, ClientboundTeams* this) {
  this->team = dec_string(src);
  this->mode = dec_byte(src);
  switch (this->mode) {
    case 0:
      this->name = dec_string(src);
      this->friendlyFire = dec_byte(src);
      this->nameTagVisibility = dec_string(src);
      this->collisionRule = dec_string(src);
      this->formatting = dec_varint(src);
      this->prefix = dec_string(src);
      this->suffix = dec_string(src);
      this->players.size = dec_varint(src);
      this->players.data = (string_t*) malloc(this->players.size * sizeof(string_t));
      for (int i1 = 0; i1 < this->players.size; i1++) {
        this->players.data[i1] = dec_string(src);
      }
      break;
    case 2:
      this->name = dec_string(src);
      this->friendlyFire = dec_byte(src);
      this->nameTagVisibility = dec_string(src);
      this->collisionRule = dec_string(src);
      this->formatting = dec_varint(src);
      this->prefix = dec_string(src);
      this->suffix = dec_string(src);
      break;
    case 3:
      this->players.size = dec_varint(src);
      this->players.data = (string_t*) malloc(this->players.size * sizeof(string_t));
      for (int i1 = 0; i1 < this->players.size; i1++) {
        this->players.data[i1] = dec_string(src);
      }
      break;
    case 4:
      this->players.size = dec_varint(src);
      this->players.data = (string_t*) malloc(this->players.size * sizeof(string_t));
      for (int i1 = 0; i1 < this->players.size; i1++) {
        this->players.data[i1] = dec_string(src);
      }
      break;
  }
}

void ClientboundScoreboardScore_encode(FILE* dest, ClientboundScoreboardScore* this) {
  enc_string(dest, this->itemName);
  enc_byte(dest, this->action);
  enc_string(dest, this->scoreName);
  if (this->action != 1) {
    enc_varint(dest, this->value);
  }
}
void ClientboundScoreboardScore_decode(FILE* src, ClientboundScoreboardScore* this) {
  this->itemName = dec_string(src);
  this->action = dec_byte(src);
  this->scoreName = dec_string(src);
  if (this->action != 1) {
    this->value = dec_varint(src);
  }
}

void ClientboundUpdateTime_encode(FILE* dest, ClientboundUpdateTime* this) {
  enc_be64(dest, this->age);
  enc_be64(dest, this->time);
}
void ClientboundUpdateTime_decode(FILE* src, ClientboundUpdateTime* this) {
  this->age = dec_be64(src);
  this->time = dec_be64(src);
}

void ClientboundTitle_encode(FILE* dest, ClientboundTitle* this) {
  enc_varint(dest, this->action);
  switch (this->action) {
    case 0:
      enc_string(dest, this->text);
      break;
    case 1:
      enc_string(dest, this->text);
      break;
    case 2:
      enc_string(dest, this->text);
      break;
    case 3:
      enc_be32(dest, this->fadeIn);
      enc_be32(dest, this->stay);
      enc_be32(dest, this->fadeOut);
      break;
  }
}
void ClientboundTitle_decode(FILE* src, ClientboundTitle* this) {
  this->action = dec_varint(src);
  switch (this->action) {
    case 0:
      this->text = dec_string(src);
      break;
    case 1:
      this->text = dec_string(src);
      break;
    case 2:
      this->text = dec_string(src);
      break;
    case 3:
      this->fadeIn = dec_be32(src);
      this->stay = dec_be32(src);
      this->fadeOut = dec_be32(src);
      break;
  }
}

void ClientboundEntitySoundEffect_encode(FILE* dest, ClientboundEntitySoundEffect* this) {
  enc_varint(dest, this->soundId);
  enc_varint(dest, this->soundCategory);
  enc_varint(dest, this->entityId);
  enc_bef32(dest, this->volume);
  enc_bef32(dest, this->pitch);
}
void ClientboundEntitySoundEffect_decode(FILE* src, ClientboundEntitySoundEffect* this) {
  this->soundId = dec_varint(src);
  this->soundCategory = dec_varint(src);
  this->entityId = dec_varint(src);
  this->volume = dec_bef32(src);
  this->pitch = dec_bef32(src);
}

void ClientboundSoundEffect_encode(FILE* dest, ClientboundSoundEffect* this) {
  enc_varint(dest, this->soundId);
  enc_varint(dest, this->soundCategory);
  enc_be32(dest, this->x);
  enc_be32(dest, this->y);
  enc_be32(dest, this->z);
  enc_bef32(dest, this->volume);
  enc_bef32(dest, this->pitch);
}
void ClientboundSoundEffect_decode(FILE* src, ClientboundSoundEffect* this) {
  this->soundId = dec_varint(src);
  this->soundCategory = dec_varint(src);
  this->x = dec_be32(src);
  this->y = dec_be32(src);
  this->z = dec_be32(src);
  this->volume = dec_bef32(src);
  this->pitch = dec_bef32(src);
}

void ClientboundStopSound_encode(FILE* dest, ClientboundStopSound* this) {
  enc_byte(dest, this->flags);
  switch (this->flags) {
    case 1:
      enc_varint(dest, this->source);
      break;
    case 2:
      enc_string(dest, this->sound);
      break;
    case 3:
      enc_varint(dest, this->source);
      enc_string(dest, this->sound);
      break;
  }
}
void ClientboundStopSound_decode(FILE* src, ClientboundStopSound* this) {
  this->flags = dec_byte(src);
  switch (this->flags) {
    case 1:
      this->source = dec_varint(src);
      break;
    case 2:
      this->sound = dec_string(src);
      break;
    case 3:
      this->source = dec_varint(src);
      this->sound = dec_string(src);
      break;
  }
}

void ClientboundPlayerlistHeader_encode(FILE* dest, ClientboundPlayerlistHeader* this) {
  enc_string(dest, this->header);
  enc_string(dest, this->footer);
}
void ClientboundPlayerlistHeader_decode(FILE* src, ClientboundPlayerlistHeader* this) {
  this->header = dec_string(src);
  this->footer = dec_string(src);
}

void ClientboundNbtQueryResponse_encode(FILE* dest, ClientboundNbtQueryResponse* this) {
  enc_varint(dest, this->transactionId);
  encode_full(dest, this->nbt);
}
void ClientboundNbtQueryResponse_decode(FILE* src, ClientboundNbtQueryResponse* this) {
  this->transactionId = dec_varint(src);
  decode_full(src, this->nbt);
}

void ClientboundCollect_encode(FILE* dest, ClientboundCollect* this) {
  enc_varint(dest, this->collectedEntityId);
  enc_varint(dest, this->collectorEntityId);
  enc_varint(dest, this->pickupItemCount);
}
void ClientboundCollect_decode(FILE* src, ClientboundCollect* this) {
  this->collectedEntityId = dec_varint(src);
  this->collectorEntityId = dec_varint(src);
  this->pickupItemCount = dec_varint(src);
}

void ClientboundEntityTeleport_encode(FILE* dest, ClientboundEntityTeleport* this) {
  enc_varint(dest, this->entityId);
  enc_bef64(dest, this->x);
  enc_bef64(dest, this->y);
  enc_bef64(dest, this->z);
  enc_byte(dest, this->yaw);
  enc_byte(dest, this->pitch);
  enc_byte(dest, this->onGround);
}
void ClientboundEntityTeleport_decode(FILE* src, ClientboundEntityTeleport* this) {
  this->entityId = dec_varint(src);
  this->x = dec_bef64(src);
  this->y = dec_bef64(src);
  this->z = dec_bef64(src);
  this->yaw = dec_byte(src);
  this->pitch = dec_byte(src);
  this->onGround = dec_byte(src);
}

void ClientboundAdvancements_encode(FILE* dest, ClientboundAdvancements* this) {
  enc_byte(dest, this->reset);
  enc_varint(dest, this->advancementMapping.size);
  for (int i0 = 0; i0 < this->advancementMapping.size; i0++) {
    enc_string(dest, this->advancementMapping.data[i0].key);
    enc_byte(dest, this->advancementMapping.data[i0].value.parentId.has_value);
    if (this->advancementMapping.data[i0].value.parentId.has_value) {
      enc_string(dest, this->advancementMapping.data[i0].value.parentId.value);
    }
    enc_byte(dest, this->advancementMapping.data[i0].value.displayData.has_value);
    if (this->advancementMapping.data[i0].value.displayData.has_value) {
      enc_string(dest, this->advancementMapping.data[i0].value.displayData.value.title);
      enc_string(dest, this->advancementMapping.data[i0].value.displayData.value.description);
      mc_slot_encode(dest, &this->advancementMapping.data[i0].value.displayData.value.icon);
      enc_varint(dest, this->advancementMapping.data[i0].value.displayData.value.frameType);
      uint32_t flags_ = 0;
      flags_ |= (((uint32_t) this->advancementMapping.data[i0].value.displayData.value.flags.hidden) & 1) << 2;
      flags_ |= (((uint32_t) this->advancementMapping.data[i0].value.displayData.value.flags.show_toast) & 1) << 1;
      flags_ |= (((uint32_t) this->advancementMapping.data[i0].value.displayData.value.flags.has_background_texture) & 1);
      enc_be32(dest, flags_);
      if (this->advancementMapping.data[i0].value.displayData.value.flags.has_background_texture == 1) {
        enc_string(dest, this->advancementMapping.data[i0].value.displayData.value.backgroundTexture);
      }
      enc_bef32(dest, this->advancementMapping.data[i0].value.displayData.value.xCord);
      enc_bef32(dest, this->advancementMapping.data[i0].value.displayData.value.yCord);
    }
    enc_varint(dest, this->advancementMapping.data[i0].value.criteria.size);
    for (int i3 = 0; i3 < this->advancementMapping.data[i0].value.criteria.size; i3++) {
      enc_string(dest, this->advancementMapping.data[i0].value.criteria.data[i3].key);
      /* 'this->advancementMapping.data[i0].value.criteria.data[i3].value' is a void type */
    }
    enc_varint(dest, this->advancementMapping.data[i0].value.requirements.size);
    for (int i3 = 0; i3 < this->advancementMapping.data[i0].value.requirements.size; i3++) {
      enc_varint(dest, this->advancementMapping.data[i0].value.requirements.data[i3].size);
      for (int i4 = 0; i4 < this->advancementMapping.data[i0].value.requirements.data[i3].size; i4++) {
        enc_string(dest, this->advancementMapping.data[i0].value.requirements.data[i3].data[i4]);
      }
    }
  }
  enc_varint(dest, this->identifiers.size);
  for (int i0 = 0; i0 < this->identifiers.size; i0++) {
    enc_string(dest, this->identifiers.data[i0]);
  }
  enc_varint(dest, this->progressMapping.size);
  for (int i0 = 0; i0 < this->progressMapping.size; i0++) {
    enc_string(dest, this->progressMapping.data[i0].key);
    enc_varint(dest, this->progressMapping.data[i0].value.size);
    for (int i2 = 0; i2 < this->progressMapping.data[i0].value.size; i2++) {
      enc_string(dest, this->progressMapping.data[i0].value.data[i2].criterionIdentifier);
      enc_byte(dest, this->progressMapping.data[i0].value.data[i2].criterionProgress.has_value);
      if (this->progressMapping.data[i0].value.data[i2].criterionProgress.has_value) {
        enc_be64(dest, this->progressMapping.data[i0].value.data[i2].criterionProgress.value);
      }
    }
  }
}
void ClientboundAdvancements_decode(FILE* src, ClientboundAdvancements* this) {
  this->reset = dec_byte(src);
  this->advancementMapping.size = dec_varint(src);
  this->advancementMapping.data = (Advancements_advancementMapping_type*) malloc(this->advancementMapping.size * sizeof(Advancements_advancementMapping_type));
  for (int i0 = 0; i0 < this->advancementMapping.size; i0++) {
    this->advancementMapping.data[i0].key = dec_string(src);
    if (dec_byte(src)) {
      this->advancementMapping.data[i0].value.parentId.has_value = true;
      this->advancementMapping.data[i0].value.parentId.value = dec_string(src);
    }
    if (dec_byte(src)) {
      this->advancementMapping.data[i0].value.displayData.has_value = true;
      this->advancementMapping.data[i0].value.displayData.value.title = dec_string(src);
      this->advancementMapping.data[i0].value.displayData.value.description = dec_string(src);
      mc_slot_decode(src, &this->advancementMapping.data[i0].value.displayData.value.icon);
      this->advancementMapping.data[i0].value.displayData.value.frameType = dec_varint(src);
      uint32_t flags_ = dec_be32(src);
      this->advancementMapping.data[i0].value.displayData.value.flags.hidden = (flags_ >> 2) & 1;
      this->advancementMapping.data[i0].value.displayData.value.flags.show_toast = (flags_ >> 1) & 1;
      this->advancementMapping.data[i0].value.displayData.value.flags.has_background_texture = (flags_) & 1;
      if (this->advancementMapping.data[i0].value.displayData.value.flags.has_background_texture == 1) {
        this->advancementMapping.data[i0].value.displayData.value.backgroundTexture = dec_string(src);
      }
      this->advancementMapping.data[i0].value.displayData.value.xCord = dec_bef32(src);
      this->advancementMapping.data[i0].value.displayData.value.yCord = dec_bef32(src);
    }
    this->advancementMapping.data[i0].value.criteria.size = dec_varint(src);
    this->advancementMapping.data[i0].value.criteria.data = (Advancements_criteria_type*) malloc(this->advancementMapping.data[i0].value.criteria.size * sizeof(Advancements_criteria_type));
    for (int i3 = 0; i3 < this->advancementMapping.data[i0].value.criteria.size; i3++) {
      this->advancementMapping.data[i0].value.criteria.data[i3].key = dec_string(src);
      /* 'this->advancementMapping.data[i0].value.criteria.data[i3].value' is a void type */
    }
    this->advancementMapping.data[i0].value.requirements.size = dec_varint(src);
    this->advancementMapping.data[i0].value.requirements.data = (string_t_vector_t*) malloc(this->advancementMapping.data[i0].value.requirements.size * sizeof(string_t_vector_t));
    for (int i3 = 0; i3 < this->advancementMapping.data[i0].value.requirements.size; i3++) {
      this->advancementMapping.data[i0].value.requirements.data[i3].size = dec_varint(src);
      this->advancementMapping.data[i0].value.requirements.data[i3].data = (string_t*) malloc(this->advancementMapping.data[i0].value.requirements.data[i3].size * sizeof(string_t));
      for (int i4 = 0; i4 < this->advancementMapping.data[i0].value.requirements.data[i3].size; i4++) {
        this->advancementMapping.data[i0].value.requirements.data[i3].data[i4] = dec_string(src);
      }
    }
  }
  this->identifiers.size = dec_varint(src);
  this->identifiers.data = (string_t*) malloc(this->identifiers.size * sizeof(string_t));
  for (int i0 = 0; i0 < this->identifiers.size; i0++) {
    this->identifiers.data[i0] = dec_string(src);
  }
  this->progressMapping.size = dec_varint(src);
  this->progressMapping.data = (Advancements_progressMapping_type*) malloc(this->progressMapping.size * sizeof(Advancements_progressMapping_type));
  for (int i0 = 0; i0 < this->progressMapping.size; i0++) {
    this->progressMapping.data[i0].key = dec_string(src);
    this->progressMapping.data[i0].value.size = dec_varint(src);
    this->progressMapping.data[i0].value.data = (Advancements_value_type*) malloc(this->progressMapping.data[i0].value.size * sizeof(Advancements_value_type));
    for (int i2 = 0; i2 < this->progressMapping.data[i0].value.size; i2++) {
      this->progressMapping.data[i0].value.data[i2].criterionIdentifier = dec_string(src);
      if (dec_byte(src)) {
        this->progressMapping.data[i0].value.data[i2].criterionProgress.has_value = true;
        this->progressMapping.data[i0].value.data[i2].criterionProgress.value = dec_be64(src);
      }
    }
  }
}

void ClientboundEntityUpdateAttributes_encode(FILE* dest, ClientboundEntityUpdateAttributes* this) {
  enc_varint(dest, this->entityId);
  enc_be32(dest, this->properties.size);
  for (int i0 = 0; i0 < this->properties.size; i0++) {
    enc_string(dest, this->properties.data[i0].key);
    enc_bef64(dest, this->properties.data[i0].value);
    enc_varint(dest, this->properties.data[i0].modifiers.size);
    for (int i2 = 0; i2 < this->properties.data[i0].modifiers.size; i2++) {
      enc_uuid(dest, this->properties.data[i0].modifiers.data[i2].uuid);
      enc_bef64(dest, this->properties.data[i0].modifiers.data[i2].amount);
      enc_byte(dest, this->properties.data[i0].modifiers.data[i2].operation);
    }
  }
}
void ClientboundEntityUpdateAttributes_decode(FILE* src, ClientboundEntityUpdateAttributes* this) {
  this->entityId = dec_varint(src);
  this->properties.size = dec_be32(src);
  this->properties.data = (EntityUpdateAttributes_properties_type*) malloc(this->properties.size * sizeof(EntityUpdateAttributes_properties_type));
  for (int i0 = 0; i0 < this->properties.size; i0++) {
    this->properties.data[i0].key = dec_string(src);
    this->properties.data[i0].value = dec_bef64(src);
    this->properties.data[i0].modifiers.size = dec_varint(src);
    this->properties.data[i0].modifiers.data = (EntityUpdateAttributes_modifiers_type*) malloc(this->properties.data[i0].modifiers.size * sizeof(EntityUpdateAttributes_modifiers_type));
    for (int i2 = 0; i2 < this->properties.data[i0].modifiers.size; i2++) {
      this->properties.data[i0].modifiers.data[i2].uuid = dec_uuid(src);
      this->properties.data[i0].modifiers.data[i2].amount = dec_bef64(src);
      this->properties.data[i0].modifiers.data[i2].operation = dec_byte(src);
    }
  }
}

void ClientboundEntityEffect_encode(FILE* dest, ClientboundEntityEffect* this) {
  enc_varint(dest, this->entityId);
  enc_byte(dest, this->effectId);
  enc_byte(dest, this->amplifier);
  enc_varint(dest, this->duration);
  enc_byte(dest, this->hideParticles);
}
void ClientboundEntityEffect_decode(FILE* src, ClientboundEntityEffect* this) {
  this->entityId = dec_varint(src);
  this->effectId = dec_byte(src);
  this->amplifier = dec_byte(src);
  this->duration = dec_varint(src);
  this->hideParticles = dec_byte(src);
}

void ClientboundDeclareRecipes_encode(FILE* dest, ClientboundDeclareRecipes* this) {
  enc_varint(dest, this->recipes.size);
  for (int i0 = 0; i0 < this->recipes.size; i0++) {
    enc_string(dest, this->recipes.data[i0].type);
    enc_string(dest, this->recipes.data[i0].recipeId);
    if (!strcmp(this->recipes.data[i0].type, "minecraft:crafting_shapeless")) {
      enc_string(dest, this->recipes.data[i0].minecraft_crafting_shapeless.group);
      enc_varint(dest, this->recipes.data[i0].minecraft_crafting_shapeless.ingredients.size);
      for (int i4 = 0; i4 < this->recipes.data[i0].minecraft_crafting_shapeless.ingredients.size; i4++) {
        enc_varint(dest, this->recipes.data[i0].minecraft_crafting_shapeless.ingredients.data[i4].size);
        for (int i5 = 0; i5 < this->recipes.data[i0].minecraft_crafting_shapeless.ingredients.data[i4].size; i5++) {
          mc_slot_encode(dest, &this->recipes.data[i0].minecraft_crafting_shapeless.ingredients.data[i4].data[i5]);
        }
      }
      mc_slot_encode(dest, &this->recipes.data[i0].minecraft_crafting_shapeless.result);
    } else if (!strcmp(this->recipes.data[i0].type, "minecraft:crafting_shaped")) {
      enc_varint(dest, this->recipes.data[i0].minecraft_crafting_shaped.width);
      enc_varint(dest, this->recipes.data[i0].minecraft_crafting_shaped.height);
      enc_string(dest, this->recipes.data[i0].minecraft_crafting_shaped.group);
      for (int i4 = 0; i4 < this->recipes.data[i0].minecraft_crafting_shaped.ingredients.size; i4++) {
        for (int i5 = 0; i5 < this->recipes.data[i0].minecraft_crafting_shaped.ingredients.data[i4].size; i5++) {
          enc_varint(dest, this->recipes.data[i0].minecraft_crafting_shaped.ingredients.data[i4].data[i5].size);
          for (int i6 = 0; i6 < this->recipes.data[i0].minecraft_crafting_shaped.ingredients.data[i4].data[i5].size; i6++) {
            mc_slot_encode(dest, &this->recipes.data[i0].minecraft_crafting_shaped.ingredients.data[i4].data[i5].data[i6]);
          }
        }
      }
      mc_slot_encode(dest, &this->recipes.data[i0].minecraft_crafting_shaped.result);
    } else if (!strcmp(this->recipes.data[i0].type, "minecraft:smelting")) {
      mc_smelting_encode(dest, &this->recipes.data[i0].minecraft_smelting);
    } else if (!strcmp(this->recipes.data[i0].type, "minecraft:blasting")) {
      mc_smelting_encode(dest, &this->recipes.data[i0].minecraft_blasting);
    } else if (!strcmp(this->recipes.data[i0].type, "minecraft:smoking")) {
      mc_smelting_encode(dest, &this->recipes.data[i0].minecraft_smoking);
    } else if (!strcmp(this->recipes.data[i0].type, "minecraft:campfire_cooking")) {
      mc_smelting_encode(dest, &this->recipes.data[i0].minecraft_campfire_cooking);
    } else if (!strcmp(this->recipes.data[i0].type, "minecraft:stonecutting")) {
      enc_string(dest, this->recipes.data[i0].minecraft_stonecutting.group);
      enc_varint(dest, this->recipes.data[i0].minecraft_stonecutting.ingredient.size);
      for (int i4 = 0; i4 < this->recipes.data[i0].minecraft_stonecutting.ingredient.size; i4++) {
        mc_slot_encode(dest, &this->recipes.data[i0].minecraft_stonecutting.ingredient.data[i4]);
      }
      mc_slot_encode(dest, &this->recipes.data[i0].minecraft_stonecutting.result);
    } else if (!strcmp(this->recipes.data[i0].type, "minecraft:smithing")) {
      enc_varint(dest, this->recipes.data[i0].minecraft_smithing.base.size);
      for (int i4 = 0; i4 < this->recipes.data[i0].minecraft_smithing.base.size; i4++) {
        mc_slot_encode(dest, &this->recipes.data[i0].minecraft_smithing.base.data[i4]);
      }
      enc_varint(dest, this->recipes.data[i0].minecraft_smithing.addition.size);
      for (int i4 = 0; i4 < this->recipes.data[i0].minecraft_smithing.addition.size; i4++) {
        mc_slot_encode(dest, &this->recipes.data[i0].minecraft_smithing.addition.data[i4]);
      }
      mc_slot_encode(dest, &this->recipes.data[i0].minecraft_smithing.result);
    }
  }
}
void ClientboundDeclareRecipes_decode(FILE* src, ClientboundDeclareRecipes* this) {
  this->recipes.size = dec_varint(src);
  this->recipes.data = (DeclareRecipes_recipes_type*) malloc(this->recipes.size * sizeof(DeclareRecipes_recipes_type));
  for (int i0 = 0; i0 < this->recipes.size; i0++) {
    this->recipes.data[i0].type = dec_string(src);
    this->recipes.data[i0].recipeId = dec_string(src);
    if (!strcmp(this->recipes.data[i0].type, "minecraft:crafting_shapeless")) {
      this->recipes.data[i0].minecraft_crafting_shapeless.group = dec_string(src);
      this->recipes.data[i0].minecraft_crafting_shapeless.ingredients.size = dec_varint(src);
      this->recipes.data[i0].minecraft_crafting_shapeless.ingredients.data = (mc_slot_vector_t*) malloc(this->recipes.data[i0].minecraft_crafting_shapeless.ingredients.size * sizeof(mc_slot_vector_t));
      for (int i4 = 0; i4 < this->recipes.data[i0].minecraft_crafting_shapeless.ingredients.size; i4++) {
        this->recipes.data[i0].minecraft_crafting_shapeless.ingredients.data[i4].size = dec_varint(src);
        this->recipes.data[i0].minecraft_crafting_shapeless.ingredients.data[i4].data = (mc_slot*) malloc(this->recipes.data[i0].minecraft_crafting_shapeless.ingredients.data[i4].size * sizeof(mc_slot));
        for (int i5 = 0; i5 < this->recipes.data[i0].minecraft_crafting_shapeless.ingredients.data[i4].size; i5++) {
          mc_slot_decode(src, &this->recipes.data[i0].minecraft_crafting_shapeless.ingredients.data[i4].data[i5]);
        }
      }
      mc_slot_decode(src, &this->recipes.data[i0].minecraft_crafting_shapeless.result);
    } else if (!strcmp(this->recipes.data[i0].type, "minecraft:crafting_shaped")) {
      this->recipes.data[i0].minecraft_crafting_shaped.width = dec_varint(src);
      this->recipes.data[i0].minecraft_crafting_shaped.height = dec_varint(src);
      this->recipes.data[i0].minecraft_crafting_shaped.group = dec_string(src);
      this->recipes.data[i0].minecraft_crafting_shaped.ingredients.size = this->recipes.data[i0].minecraft_crafting_shaped.width;
      this->recipes.data[i0].minecraft_crafting_shaped.ingredients.data = (mc_slot_vector_t_vector_t*) malloc(this->recipes.data[i0].minecraft_crafting_shaped.ingredients.size * sizeof(mc_slot_vector_t_vector_t));
      for (int i4 = 0; i4 < this->recipes.data[i0].minecraft_crafting_shaped.ingredients.size; i4++) {
        this->recipes.data[i0].minecraft_crafting_shaped.ingredients.data[i4].size = this->recipes.data[i0].minecraft_crafting_shaped.height;
        this->recipes.data[i0].minecraft_crafting_shaped.ingredients.data[i4].data = (mc_slot_vector_t*) malloc(this->recipes.data[i0].minecraft_crafting_shaped.ingredients.data[i4].size * sizeof(mc_slot_vector_t));
        for (int i5 = 0; i5 < this->recipes.data[i0].minecraft_crafting_shaped.ingredients.data[i4].size; i5++) {
          this->recipes.data[i0].minecraft_crafting_shaped.ingredients.data[i4].data[i5].size = dec_varint(src);
          this->recipes.data[i0].minecraft_crafting_shaped.ingredients.data[i4].data[i5].data = (mc_slot*) malloc(this->recipes.data[i0].minecraft_crafting_shaped.ingredients.data[i4].data[i5].size * sizeof(mc_slot));
          for (int i6 = 0; i6 < this->recipes.data[i0].minecraft_crafting_shaped.ingredients.data[i4].data[i5].size; i6++) {
            mc_slot_decode(src, &this->recipes.data[i0].minecraft_crafting_shaped.ingredients.data[i4].data[i5].data[i6]);
          }
        }
      }
      mc_slot_decode(src, &this->recipes.data[i0].minecraft_crafting_shaped.result);
    } else if (!strcmp(this->recipes.data[i0].type, "minecraft:smelting")) {
      mc_smelting_decode(src, &this->recipes.data[i0].minecraft_smelting);
    } else if (!strcmp(this->recipes.data[i0].type, "minecraft:blasting")) {
      mc_smelting_decode(src, &this->recipes.data[i0].minecraft_blasting);
    } else if (!strcmp(this->recipes.data[i0].type, "minecraft:smoking")) {
      mc_smelting_decode(src, &this->recipes.data[i0].minecraft_smoking);
    } else if (!strcmp(this->recipes.data[i0].type, "minecraft:campfire_cooking")) {
      mc_smelting_decode(src, &this->recipes.data[i0].minecraft_campfire_cooking);
    } else if (!strcmp(this->recipes.data[i0].type, "minecraft:stonecutting")) {
      this->recipes.data[i0].minecraft_stonecutting.group = dec_string(src);
      this->recipes.data[i0].minecraft_stonecutting.ingredient.size = dec_varint(src);
      this->recipes.data[i0].minecraft_stonecutting.ingredient.data = (mc_slot*) malloc(this->recipes.data[i0].minecraft_stonecutting.ingredient.size * sizeof(mc_slot));
      for (int i4 = 0; i4 < this->recipes.data[i0].minecraft_stonecutting.ingredient.size; i4++) {
        mc_slot_decode(src, &this->recipes.data[i0].minecraft_stonecutting.ingredient.data[i4]);
      }
      mc_slot_decode(src, &this->recipes.data[i0].minecraft_stonecutting.result);
    } else if (!strcmp(this->recipes.data[i0].type, "minecraft:smithing")) {
      this->recipes.data[i0].minecraft_smithing.base.size = dec_varint(src);
      this->recipes.data[i0].minecraft_smithing.base.data = (mc_slot*) malloc(this->recipes.data[i0].minecraft_smithing.base.size * sizeof(mc_slot));
      for (int i4 = 0; i4 < this->recipes.data[i0].minecraft_smithing.base.size; i4++) {
        mc_slot_decode(src, &this->recipes.data[i0].minecraft_smithing.base.data[i4]);
      }
      this->recipes.data[i0].minecraft_smithing.addition.size = dec_varint(src);
      this->recipes.data[i0].minecraft_smithing.addition.data = (mc_slot*) malloc(this->recipes.data[i0].minecraft_smithing.addition.size * sizeof(mc_slot));
      for (int i4 = 0; i4 < this->recipes.data[i0].minecraft_smithing.addition.size; i4++) {
        mc_slot_decode(src, &this->recipes.data[i0].minecraft_smithing.addition.data[i4]);
      }
      mc_slot_decode(src, &this->recipes.data[i0].minecraft_smithing.result);
    }
  }
}

void ClientboundTags_encode(FILE* dest, ClientboundTags* this) {
  enc_varint(dest, this->blockTags.size);
  for (int i0 = 0; i0 < this->blockTags.size; i0++) {
    mc_tag_encode(dest, &this->blockTags.data[i0]);
  }
  enc_varint(dest, this->itemTags.size);
  for (int i0 = 0; i0 < this->itemTags.size; i0++) {
    mc_tag_encode(dest, &this->itemTags.data[i0]);
  }
  enc_varint(dest, this->fluidTags.size);
  for (int i0 = 0; i0 < this->fluidTags.size; i0++) {
    mc_tag_encode(dest, &this->fluidTags.data[i0]);
  }
  enc_varint(dest, this->entityTags.size);
  for (int i0 = 0; i0 < this->entityTags.size; i0++) {
    mc_tag_encode(dest, &this->entityTags.data[i0]);
  }
}
void ClientboundTags_decode(FILE* src, ClientboundTags* this) {
  this->blockTags.size = dec_varint(src);
  this->blockTags.data = (mc_tag*) malloc(this->blockTags.size * sizeof(mc_tag));
  for (int i0 = 0; i0 < this->blockTags.size; i0++) {
    mc_tag_decode(src, &this->blockTags.data[i0]);
  }
  this->itemTags.size = dec_varint(src);
  this->itemTags.data = (mc_tag*) malloc(this->itemTags.size * sizeof(mc_tag));
  for (int i0 = 0; i0 < this->itemTags.size; i0++) {
    mc_tag_decode(src, &this->itemTags.data[i0]);
  }
  this->fluidTags.size = dec_varint(src);
  this->fluidTags.data = (mc_tag*) malloc(this->fluidTags.size * sizeof(mc_tag));
  for (int i0 = 0; i0 < this->fluidTags.size; i0++) {
    mc_tag_decode(src, &this->fluidTags.data[i0]);
  }
  this->entityTags.size = dec_varint(src);
  this->entityTags.data = (mc_tag*) malloc(this->entityTags.size * sizeof(mc_tag));
  for (int i0 = 0; i0 < this->entityTags.size; i0++) {
    mc_tag_decode(src, &this->entityTags.data[i0]);
  }
}

void ServerboundTeleportConfirm_encode(FILE* dest, ServerboundTeleportConfirm* this) {
  enc_varint(dest, this->teleportId);
}
void ServerboundTeleportConfirm_decode(FILE* src, ServerboundTeleportConfirm* this) {
  this->teleportId = dec_varint(src);
}

void ServerboundQueryBlockNbt_encode(FILE* dest, ServerboundQueryBlockNbt* this) {
  enc_varint(dest, this->transactionId);
  enc_position(dest, this->location);
}
void ServerboundQueryBlockNbt_decode(FILE* src, ServerboundQueryBlockNbt* this) {
  this->transactionId = dec_varint(src);
  this->location = dec_position(src);
}

void ServerboundSetDifficulty_encode(FILE* dest, ServerboundSetDifficulty* this) {
  enc_byte(dest, this->newDifficulty);
}
void ServerboundSetDifficulty_decode(FILE* src, ServerboundSetDifficulty* this) {
  this->newDifficulty = dec_byte(src);
}

void ServerboundChat_encode(FILE* dest, ServerboundChat* this) {
  enc_string(dest, this->message);
}
void ServerboundChat_decode(FILE* src, ServerboundChat* this) {
  this->message = dec_string(src);
}

void ServerboundClientCommand_encode(FILE* dest, ServerboundClientCommand* this) {
  enc_varint(dest, this->actionId);
}
void ServerboundClientCommand_decode(FILE* src, ServerboundClientCommand* this) {
  this->actionId = dec_varint(src);
}

void ServerboundSettings_encode(FILE* dest, ServerboundSettings* this) {
  enc_string(dest, this->locale);
  enc_byte(dest, this->viewDistance);
  enc_varint(dest, this->chatFlags);
  enc_byte(dest, this->chatColors);
  enc_byte(dest, this->skinParts);
  enc_varint(dest, this->mainHand);
}
void ServerboundSettings_decode(FILE* src, ServerboundSettings* this) {
  this->locale = dec_string(src);
  this->viewDistance = dec_byte(src);
  this->chatFlags = dec_varint(src);
  this->chatColors = dec_byte(src);
  this->skinParts = dec_byte(src);
  this->mainHand = dec_varint(src);
}

void ServerboundTabComplete_encode(FILE* dest, ServerboundTabComplete* this) {
  enc_varint(dest, this->transactionId);
  enc_string(dest, this->text);
}
void ServerboundTabComplete_decode(FILE* src, ServerboundTabComplete* this) {
  this->transactionId = dec_varint(src);
  this->text = dec_string(src);
}

void ServerboundTransaction_encode(FILE* dest, ServerboundTransaction* this) {
  enc_byte(dest, this->windowId);
  enc_be16(dest, this->action);
  enc_byte(dest, this->accepted);
}
void ServerboundTransaction_decode(FILE* src, ServerboundTransaction* this) {
  this->windowId = dec_byte(src);
  this->action = dec_be16(src);
  this->accepted = dec_byte(src);
}

void ServerboundEnchantItem_encode(FILE* dest, ServerboundEnchantItem* this) {
  enc_byte(dest, this->windowId);
  enc_byte(dest, this->enchantment);
}
void ServerboundEnchantItem_decode(FILE* src, ServerboundEnchantItem* this) {
  this->windowId = dec_byte(src);
  this->enchantment = dec_byte(src);
}

void ServerboundWindowClick_encode(FILE* dest, ServerboundWindowClick* this) {
  enc_byte(dest, this->windowId);
  enc_be16(dest, this->slot);
  enc_byte(dest, this->mouseButton);
  enc_be16(dest, this->action);
  enc_byte(dest, this->mode);
  mc_slot_encode(dest, &this->item);
}
void ServerboundWindowClick_decode(FILE* src, ServerboundWindowClick* this) {
  this->windowId = dec_byte(src);
  this->slot = dec_be16(src);
  this->mouseButton = dec_byte(src);
  this->action = dec_be16(src);
  this->mode = dec_byte(src);
  mc_slot_decode(src, &this->item);
}

void ServerboundCloseWindow_encode(FILE* dest, ServerboundCloseWindow* this) {
  enc_byte(dest, this->windowId);
}
void ServerboundCloseWindow_decode(FILE* src, ServerboundCloseWindow* this) {
  this->windowId = dec_byte(src);
}

void ServerboundCustomPayload_encode(FILE* dest, ServerboundCustomPayload* this) {
  enc_string(dest, this->channel);
  fwrite(this->data.data, sizeof(char), this->data.size, dest);
}
void ServerboundCustomPayload_decode(FILE* src, ServerboundCustomPayload* this) {
  this->channel = dec_string(src);
  this->data.size = 0; /* todo */
}

void ServerboundEditBook_encode(FILE* dest, ServerboundEditBook* this) {
  mc_slot_encode(dest, &this->new_book);
  enc_byte(dest, this->signing);
  enc_varint(dest, this->hand);
}
void ServerboundEditBook_decode(FILE* src, ServerboundEditBook* this) {
  mc_slot_decode(src, &this->new_book);
  this->signing = dec_byte(src);
  this->hand = dec_varint(src);
}

void ServerboundQueryEntityNbt_encode(FILE* dest, ServerboundQueryEntityNbt* this) {
  enc_varint(dest, this->transactionId);
  enc_varint(dest, this->entityId);
}
void ServerboundQueryEntityNbt_decode(FILE* src, ServerboundQueryEntityNbt* this) {
  this->transactionId = dec_varint(src);
  this->entityId = dec_varint(src);
}

void ServerboundUseEntity_encode(FILE* dest, ServerboundUseEntity* this) {
  enc_varint(dest, this->target);
  enc_varint(dest, this->mouse);
  switch (this->mouse) {
    case 0:
      enc_varint(dest, this->hand);
      break;
    case 2:
      enc_bef32(dest, this->x);
      enc_bef32(dest, this->y);
      enc_bef32(dest, this->z);
      enc_varint(dest, this->hand);
      break;
  }
  enc_byte(dest, this->sneaking);
}
void ServerboundUseEntity_decode(FILE* src, ServerboundUseEntity* this) {
  this->target = dec_varint(src);
  this->mouse = dec_varint(src);
  switch (this->mouse) {
    case 0:
      this->hand = dec_varint(src);
      break;
    case 2:
      this->x = dec_bef32(src);
      this->y = dec_bef32(src);
      this->z = dec_bef32(src);
      this->hand = dec_varint(src);
      break;
  }
  this->sneaking = dec_byte(src);
}

void ServerboundGenerateStructure_encode(FILE* dest, ServerboundGenerateStructure* this) {
  enc_position(dest, this->location);
  enc_varint(dest, this->levels);
  enc_byte(dest, this->keepJigsaws);
}
void ServerboundGenerateStructure_decode(FILE* src, ServerboundGenerateStructure* this) {
  this->location = dec_position(src);
  this->levels = dec_varint(src);
  this->keepJigsaws = dec_byte(src);
}

void ServerboundKeepAlive_encode(FILE* dest, ServerboundKeepAlive* this) {
  enc_be64(dest, this->keepAliveId);
}
void ServerboundKeepAlive_decode(FILE* src, ServerboundKeepAlive* this) {
  this->keepAliveId = dec_be64(src);
}

void ServerboundLockDifficulty_encode(FILE* dest, ServerboundLockDifficulty* this) {
  enc_byte(dest, this->locked);
}
void ServerboundLockDifficulty_decode(FILE* src, ServerboundLockDifficulty* this) {
  this->locked = dec_byte(src);
}

void ServerboundPosition_encode(FILE* dest, ServerboundPosition* this) {
  enc_bef64(dest, this->x);
  enc_bef64(dest, this->y);
  enc_bef64(dest, this->z);
  enc_byte(dest, this->onGround);
}
void ServerboundPosition_decode(FILE* src, ServerboundPosition* this) {
  this->x = dec_bef64(src);
  this->y = dec_bef64(src);
  this->z = dec_bef64(src);
  this->onGround = dec_byte(src);
}

void ServerboundPositionLook_encode(FILE* dest, ServerboundPositionLook* this) {
  enc_bef64(dest, this->x);
  enc_bef64(dest, this->y);
  enc_bef64(dest, this->z);
  enc_bef32(dest, this->yaw);
  enc_bef32(dest, this->pitch);
  enc_byte(dest, this->onGround);
}
void ServerboundPositionLook_decode(FILE* src, ServerboundPositionLook* this) {
  this->x = dec_bef64(src);
  this->y = dec_bef64(src);
  this->z = dec_bef64(src);
  this->yaw = dec_bef32(src);
  this->pitch = dec_bef32(src);
  this->onGround = dec_byte(src);
}

void ServerboundLook_encode(FILE* dest, ServerboundLook* this) {
  enc_bef32(dest, this->yaw);
  enc_bef32(dest, this->pitch);
  enc_byte(dest, this->onGround);
}
void ServerboundLook_decode(FILE* src, ServerboundLook* this) {
  this->yaw = dec_bef32(src);
  this->pitch = dec_bef32(src);
  this->onGround = dec_byte(src);
}

void ServerboundFlying_encode(FILE* dest, ServerboundFlying* this) {
  enc_byte(dest, this->onGround);
}
void ServerboundFlying_decode(FILE* src, ServerboundFlying* this) {
  this->onGround = dec_byte(src);
}

void ServerboundVehicleMove_encode(FILE* dest, ServerboundVehicleMove* this) {
  enc_bef64(dest, this->x);
  enc_bef64(dest, this->y);
  enc_bef64(dest, this->z);
  enc_bef32(dest, this->yaw);
  enc_bef32(dest, this->pitch);
}
void ServerboundVehicleMove_decode(FILE* src, ServerboundVehicleMove* this) {
  this->x = dec_bef64(src);
  this->y = dec_bef64(src);
  this->z = dec_bef64(src);
  this->yaw = dec_bef32(src);
  this->pitch = dec_bef32(src);
}

void ServerboundSteerBoat_encode(FILE* dest, ServerboundSteerBoat* this) {
  enc_byte(dest, this->leftPaddle);
  enc_byte(dest, this->rightPaddle);
}
void ServerboundSteerBoat_decode(FILE* src, ServerboundSteerBoat* this) {
  this->leftPaddle = dec_byte(src);
  this->rightPaddle = dec_byte(src);
}

void ServerboundPickItem_encode(FILE* dest, ServerboundPickItem* this) {
  enc_varint(dest, this->slot);
}
void ServerboundPickItem_decode(FILE* src, ServerboundPickItem* this) {
  this->slot = dec_varint(src);
}

void ServerboundCraftRecipeRequest_encode(FILE* dest, ServerboundCraftRecipeRequest* this) {
  enc_byte(dest, this->windowId);
  enc_string(dest, this->recipe);
  enc_byte(dest, this->makeAll);
}
void ServerboundCraftRecipeRequest_decode(FILE* src, ServerboundCraftRecipeRequest* this) {
  this->windowId = dec_byte(src);
  this->recipe = dec_string(src);
  this->makeAll = dec_byte(src);
}

void ServerboundAbilities_encode(FILE* dest, ServerboundAbilities* this) {
  enc_byte(dest, this->flags);
}
void ServerboundAbilities_decode(FILE* src, ServerboundAbilities* this) {
  this->flags = dec_byte(src);
}

void ServerboundBlockDig_encode(FILE* dest, ServerboundBlockDig* this) {
  enc_byte(dest, this->status);
  enc_position(dest, this->location);
  enc_byte(dest, this->face);
}
void ServerboundBlockDig_decode(FILE* src, ServerboundBlockDig* this) {
  this->status = dec_byte(src);
  this->location = dec_position(src);
  this->face = dec_byte(src);
}

void ServerboundEntityAction_encode(FILE* dest, ServerboundEntityAction* this) {
  enc_varint(dest, this->entityId);
  enc_varint(dest, this->actionId);
  enc_varint(dest, this->jumpBoost);
}
void ServerboundEntityAction_decode(FILE* src, ServerboundEntityAction* this) {
  this->entityId = dec_varint(src);
  this->actionId = dec_varint(src);
  this->jumpBoost = dec_varint(src);
}

void ServerboundSteerVehicle_encode(FILE* dest, ServerboundSteerVehicle* this) {
  enc_bef32(dest, this->sideways);
  enc_bef32(dest, this->forward);
  enc_byte(dest, this->jump);
}
void ServerboundSteerVehicle_decode(FILE* src, ServerboundSteerVehicle* this) {
  this->sideways = dec_bef32(src);
  this->forward = dec_bef32(src);
  this->jump = dec_byte(src);
}

void ServerboundCraftingBookData_encode(FILE* dest, ServerboundCraftingBookData* this) {
  enc_varint(dest, this->type);
  switch (this->type) {
    case 0:
      enc_string(dest, this->displayedRecipe);
      break;
    case 1:
      enc_byte(dest, this->craftingBookOpen);
      enc_byte(dest, this->craftingFilter);
      enc_byte(dest, this->smeltingBookOpen);
      enc_byte(dest, this->smeltingFilter);
      enc_byte(dest, this->blastingBookOpen);
      enc_byte(dest, this->blastingFilter);
      enc_byte(dest, this->smokingBookOpen);
      enc_byte(dest, this->smokingFilter);
      break;
  }
}
void ServerboundCraftingBookData_decode(FILE* src, ServerboundCraftingBookData* this) {
  this->type = dec_varint(src);
  switch (this->type) {
    case 0:
      this->displayedRecipe = dec_string(src);
      break;
    case 1:
      this->craftingBookOpen = dec_byte(src);
      this->craftingFilter = dec_byte(src);
      this->smeltingBookOpen = dec_byte(src);
      this->smeltingFilter = dec_byte(src);
      this->blastingBookOpen = dec_byte(src);
      this->blastingFilter = dec_byte(src);
      this->smokingBookOpen = dec_byte(src);
      this->smokingFilter = dec_byte(src);
      break;
  }
}

void ServerboundNameItem_encode(FILE* dest, ServerboundNameItem* this) {
  enc_string(dest, this->name);
}
void ServerboundNameItem_decode(FILE* src, ServerboundNameItem* this) {
  this->name = dec_string(src);
}

void ServerboundResourcePackReceive_encode(FILE* dest, ServerboundResourcePackReceive* this) {
  enc_varint(dest, this->result);
}
void ServerboundResourcePackReceive_decode(FILE* src, ServerboundResourcePackReceive* this) {
  this->result = dec_varint(src);
}

void ServerboundAdvancementTab_encode(FILE* dest, ServerboundAdvancementTab* this) {
  enc_varint(dest, this->action);
  if (this->action == 0) {
    enc_string(dest, this->tabId);
  }
}
void ServerboundAdvancementTab_decode(FILE* src, ServerboundAdvancementTab* this) {
  this->action = dec_varint(src);
  if (this->action == 0) {
    this->tabId = dec_string(src);
  }
}

void ServerboundSelectTrade_encode(FILE* dest, ServerboundSelectTrade* this) {
  enc_varint(dest, this->slot);
}
void ServerboundSelectTrade_decode(FILE* src, ServerboundSelectTrade* this) {
  this->slot = dec_varint(src);
}

void ServerboundSetBeaconEffect_encode(FILE* dest, ServerboundSetBeaconEffect* this) {
  enc_varint(dest, this->primary_effect);
  enc_varint(dest, this->secondary_effect);
}
void ServerboundSetBeaconEffect_decode(FILE* src, ServerboundSetBeaconEffect* this) {
  this->primary_effect = dec_varint(src);
  this->secondary_effect = dec_varint(src);
}

void ServerboundHeldItemSlot_encode(FILE* dest, ServerboundHeldItemSlot* this) {
  enc_be16(dest, this->slotId);
}
void ServerboundHeldItemSlot_decode(FILE* src, ServerboundHeldItemSlot* this) {
  this->slotId = dec_be16(src);
}

void ServerboundUpdateCommandBlock_encode(FILE* dest, ServerboundUpdateCommandBlock* this) {
  enc_position(dest, this->location);
  enc_string(dest, this->command);
  enc_varint(dest, this->mode);
  enc_byte(dest, this->flags);
}
void ServerboundUpdateCommandBlock_decode(FILE* src, ServerboundUpdateCommandBlock* this) {
  this->location = dec_position(src);
  this->command = dec_string(src);
  this->mode = dec_varint(src);
  this->flags = dec_byte(src);
}

void ServerboundUpdateCommandBlockMinecart_encode(FILE* dest, ServerboundUpdateCommandBlockMinecart* this) {
  enc_varint(dest, this->entityId);
  enc_string(dest, this->command);
  enc_byte(dest, this->track_output);
}
void ServerboundUpdateCommandBlockMinecart_decode(FILE* src, ServerboundUpdateCommandBlockMinecart* this) {
  this->entityId = dec_varint(src);
  this->command = dec_string(src);
  this->track_output = dec_byte(src);
}

void ServerboundSetCreativeSlot_encode(FILE* dest, ServerboundSetCreativeSlot* this) {
  enc_be16(dest, this->slot);
  mc_slot_encode(dest, &this->item);
}
void ServerboundSetCreativeSlot_decode(FILE* src, ServerboundSetCreativeSlot* this) {
  this->slot = dec_be16(src);
  mc_slot_decode(src, &this->item);
}

void ServerboundUpdateJigsawBlock_encode(FILE* dest, ServerboundUpdateJigsawBlock* this) {
  enc_position(dest, this->location);
  enc_string(dest, this->name);
  enc_string(dest, this->target);
  enc_string(dest, this->pool);
  enc_string(dest, this->finalState);
  enc_string(dest, this->jointType);
}
void ServerboundUpdateJigsawBlock_decode(FILE* src, ServerboundUpdateJigsawBlock* this) {
  this->location = dec_position(src);
  this->name = dec_string(src);
  this->target = dec_string(src);
  this->pool = dec_string(src);
  this->finalState = dec_string(src);
  this->jointType = dec_string(src);
}

void ServerboundUpdateStructureBlock_encode(FILE* dest, ServerboundUpdateStructureBlock* this) {
  enc_position(dest, this->location);
  enc_varint(dest, this->action);
  enc_varint(dest, this->mode);
  enc_string(dest, this->name);
  enc_byte(dest, this->offset_x);
  enc_byte(dest, this->offset_y);
  enc_byte(dest, this->offset_z);
  enc_byte(dest, this->size_x);
  enc_byte(dest, this->size_y);
  enc_byte(dest, this->size_z);
  enc_varint(dest, this->mirror);
  enc_varint(dest, this->rotation);
  enc_string(dest, this->metadata);
  enc_bef32(dest, this->integrity);
  enc_varint(dest, this->seed);
  enc_byte(dest, this->flags);
}
void ServerboundUpdateStructureBlock_decode(FILE* src, ServerboundUpdateStructureBlock* this) {
  this->location = dec_position(src);
  this->action = dec_varint(src);
  this->mode = dec_varint(src);
  this->name = dec_string(src);
  this->offset_x = dec_byte(src);
  this->offset_y = dec_byte(src);
  this->offset_z = dec_byte(src);
  this->size_x = dec_byte(src);
  this->size_y = dec_byte(src);
  this->size_z = dec_byte(src);
  this->mirror = dec_varint(src);
  this->rotation = dec_varint(src);
  this->metadata = dec_string(src);
  this->integrity = dec_bef32(src);
  this->seed = dec_varint(src);
  this->flags = dec_byte(src);
}

void ServerboundUpdateSign_encode(FILE* dest, ServerboundUpdateSign* this) {
  enc_position(dest, this->location);
  enc_string(dest, this->text1);
  enc_string(dest, this->text2);
  enc_string(dest, this->text3);
  enc_string(dest, this->text4);
}
void ServerboundUpdateSign_decode(FILE* src, ServerboundUpdateSign* this) {
  this->location = dec_position(src);
  this->text1 = dec_string(src);
  this->text2 = dec_string(src);
  this->text3 = dec_string(src);
  this->text4 = dec_string(src);
}

void ServerboundArmAnimation_encode(FILE* dest, ServerboundArmAnimation* this) {
  enc_varint(dest, this->hand);
}
void ServerboundArmAnimation_decode(FILE* src, ServerboundArmAnimation* this) {
  this->hand = dec_varint(src);
}

void ServerboundSpectate_encode(FILE* dest, ServerboundSpectate* this) {
  enc_uuid(dest, this->target);
}
void ServerboundSpectate_decode(FILE* src, ServerboundSpectate* this) {
  this->target = dec_uuid(src);
}

void ServerboundBlockPlace_encode(FILE* dest, ServerboundBlockPlace* this) {
  enc_varint(dest, this->hand);
  enc_position(dest, this->location);
  enc_varint(dest, this->direction);
  enc_bef32(dest, this->cursorX);
  enc_bef32(dest, this->cursorY);
  enc_bef32(dest, this->cursorZ);
  enc_byte(dest, this->insideBlock);
}
void ServerboundBlockPlace_decode(FILE* src, ServerboundBlockPlace* this) {
  this->hand = dec_varint(src);
  this->location = dec_position(src);
  this->direction = dec_varint(src);
  this->cursorX = dec_bef32(src);
  this->cursorY = dec_bef32(src);
  this->cursorZ = dec_bef32(src);
  this->insideBlock = dec_byte(src);
}

void ServerboundUseItem_encode(FILE* dest, ServerboundUseItem* this) {
  enc_varint(dest, this->hand);
}
void ServerboundUseItem_decode(FILE* src, ServerboundUseItem* this) {
  this->hand = dec_varint(src);
}

Packet* make_packet(packet_state state, packet_direction dir, int packet_id) {
  /*switch(state) {
    case HANDSHAKING:
      switch(dir) {
        case CLIENTBOUND:
          switch(packet_id) {
            default:
              runtime_error("Invalid Packet Id");
          }
        case SERVERBOUND:
          switch(packet_id) {
             case SB_HS_SET_PROTOCOL:
               return ServerboundSetProtocol;
            default:
              runtime_error("Invalid Packet Id");
          }
        default:
          runtime_error("Invalid Packet Direction");
      }
    case STATUS:
      switch(dir) {
        case CLIENTBOUND:
          switch(packet_id) {
             case CB_ST_SERVER_INFO:
               return ClientboundServerInfo;
             case CB_ST_PING:
               return ClientboundPing;
            default:
              runtime_error("Invalid Packet Id");
          }
        case SERVERBOUND:
          switch(packet_id) {
             case SB_ST_PING_START:
               return ServerboundPingStart;
             case SB_ST_PING:
               return ServerboundPing;
            default:
              runtime_error("Invalid Packet Id");
          }
        default:
          runtime_error("Invalid Packet Direction");
      }
    case LOGIN:
      switch(dir) {
        case CLIENTBOUND:
          switch(packet_id) {
             case CB_LG_DISCONNECT:
               return ClientboundDisconnect;
             case CB_LG_ENCRYPTION_BEGIN:
               return ClientboundEncryptionBegin;
             case CB_LG_SUCCESS:
               return ClientboundSuccess;
             case CB_LG_COMPRESS:
               return ClientboundCompress;
             case CB_LG_LOGIN_PLUGIN_REQUEST:
               return ClientboundLoginPluginRequest;
            default:
              runtime_error("Invalid Packet Id");
          }
        case SERVERBOUND:
          switch(packet_id) {
             case SB_LG_LOGIN_START:
               return ServerboundLoginStart;
             case SB_LG_ENCRYPTION_BEGIN:
               return ServerboundEncryptionBegin;
             case SB_LG_LOGIN_PLUGIN_RESPONSE:
               return ServerboundLoginPluginResponse;
            default:
              runtime_error("Invalid Packet Id");
          }
        default:
          runtime_error("Invalid Packet Direction");
      }
    case PLAY:
      switch(dir) {
        case CLIENTBOUND:
          switch(packet_id) {
             case CB_PL_SPAWN_ENTITY:
               return ClientboundSpawnEntity;
             case CB_PL_SPAWN_ENTITY_EXPERIENCE_ORB:
               return ClientboundSpawnEntityExperienceOrb;
             case CB_PL_SPAWN_ENTITY_LIVING:
               return ClientboundSpawnEntityLiving;
             case CB_PL_SPAWN_ENTITY_PAINTING:
               return ClientboundSpawnEntityPainting;
             case CB_PL_NAMED_ENTITY_SPAWN:
               return ClientboundNamedEntitySpawn;
             case CB_PL_ANIMATION:
               return ClientboundAnimation;
             case CB_PL_STATISTICS:
               return ClientboundStatistics;
             case CB_PL_ACKNOWLEDGE_PLAYER_DIGGING:
               return ClientboundAcknowledgePlayerDigging;
             case CB_PL_BLOCK_BREAK_ANIMATION:
               return ClientboundBlockBreakAnimation;
             case CB_PL_TILE_ENTITY_DATA:
               return ClientboundTileEntityData;
             case CB_PL_BLOCK_ACTION:
               return ClientboundBlockAction;
             case CB_PL_BLOCK_CHANGE:
               return ClientboundBlockChange;
             case CB_PL_BOSS_BAR:
               return ClientboundBossBar;
             case CB_PL_DIFFICULTY:
               return ClientboundDifficulty;
             case CB_PL_CHAT:
               return ClientboundChat;
             case CB_PL_MULTI_BLOCK_CHANGE:
               return ClientboundMultiBlockChange;
             case CB_PL_TAB_COMPLETE:
               return ClientboundTabComplete;
             case CB_PL_DECLARE_COMMANDS:
               return ClientboundDeclareCommands;
             case CB_PL_TRANSACTION:
               return ClientboundTransaction;
             case CB_PL_CLOSE_WINDOW:
               return ClientboundCloseWindow;
             case CB_PL_WINDOW_ITEMS:
               return ClientboundWindowItems;
             case CB_PL_CRAFT_PROGRESS_BAR:
               return ClientboundCraftProgressBar;
             case CB_PL_SET_SLOT:
               return ClientboundSetSlot;
             case CB_PL_SET_COOLDOWN:
               return ClientboundSetCooldown;
             case CB_PL_CUSTOM_PAYLOAD:
               return ClientboundCustomPayload;
             case CB_PL_NAMED_SOUND_EFFECT:
               return ClientboundNamedSoundEffect;
             case CB_PL_KICK_DISCONNECT:
               return ClientboundKickDisconnect;
             case CB_PL_ENTITY_STATUS:
               return ClientboundEntityStatus;
             case CB_PL_EXPLOSION:
               return ClientboundExplosion;
             case CB_PL_UNLOAD_CHUNK:
               return ClientboundUnloadChunk;
             case CB_PL_GAME_STATE_CHANGE:
               return ClientboundGameStateChange;
             case CB_PL_OPEN_HORSE_WINDOW:
               return ClientboundOpenHorseWindow;
             case CB_PL_KEEP_ALIVE:
               return ClientboundKeepAlive;
             case CB_PL_MAP_CHUNK:
               return ClientboundMapChunk;
             case CB_PL_WORLD_EVENT:
               return ClientboundWorldEvent;
             case CB_PL_WORLD_PARTICLES:
               return ClientboundWorldParticles;
             case CB_PL_UPDATE_LIGHT:
               return ClientboundUpdateLight;
             case CB_PL_LOGIN:
               return ClientboundLogin;
             case CB_PL_MAP:
               return ClientboundMap;
             case CB_PL_TRADE_LIST:
               return ClientboundTradeList;
             case CB_PL_REL_ENTITY_MOVE:
               return ClientboundRelEntityMove;
             case CB_PL_ENTITY_MOVE_LOOK:
               return ClientboundEntityMoveLook;
             case CB_PL_ENTITY_LOOK:
               return ClientboundEntityLook;
             case CB_PL_ENTITY:
               return ClientboundEntity;
             case CB_PL_VEHICLE_MOVE:
               return ClientboundVehicleMove;
             case CB_PL_OPEN_BOOK:
               return ClientboundOpenBook;
             case CB_PL_OPEN_WINDOW:
               return ClientboundOpenWindow;
             case CB_PL_OPEN_SIGN_ENTITY:
               return ClientboundOpenSignEntity;
             case CB_PL_CRAFT_RECIPE_RESPONSE:
               return ClientboundCraftRecipeResponse;
             case CB_PL_ABILITIES:
               return ClientboundAbilities;
             case CB_PL_COMBAT_EVENT:
               return ClientboundCombatEvent;
             case CB_PL_PLAYER_INFO:
               return ClientboundPlayerInfo;
             case CB_PL_FACE_PLAYER:
               return ClientboundFacePlayer;
             case CB_PL_POSITION:
               return ClientboundPosition;
             case CB_PL_UNLOCK_RECIPES:
               return ClientboundUnlockRecipes;
             case CB_PL_ENTITY_DESTROY:
               return ClientboundEntityDestroy;
             case CB_PL_REMOVE_ENTITY_EFFECT:
               return ClientboundRemoveEntityEffect;
             case CB_PL_RESOURCE_PACK_SEND:
               return ClientboundResourcePackSend;
             case CB_PL_RESPAWN:
               return ClientboundRespawn;
             case CB_PL_ENTITY_HEAD_ROTATION:
               return ClientboundEntityHeadRotation;
             case CB_PL_SELECT_ADVANCEMENT_TAB:
               return ClientboundSelectAdvancementTab;
             case CB_PL_WORLD_BORDER:
               return ClientboundWorldBorder;
             case CB_PL_CAMERA:
               return ClientboundCamera;
             case CB_PL_HELD_ITEM_SLOT:
               return ClientboundHeldItemSlot;
             case CB_PL_UPDATE_VIEW_POSITION:
               return ClientboundUpdateViewPosition;
             case CB_PL_UPDATE_VIEW_DISTANCE:
               return ClientboundUpdateViewDistance;
             case CB_PL_SPAWN_POSITION:
               return ClientboundSpawnPosition;
             case CB_PL_SCOREBOARD_DISPLAY_OBJECTIVE:
               return ClientboundScoreboardDisplayObjective;
             case CB_PL_ENTITY_METADATA:
               return ClientboundEntityMetadata;
             case CB_PL_ATTACH_ENTITY:
               return ClientboundAttachEntity;
             case CB_PL_ENTITY_VELOCITY:
               return ClientboundEntityVelocity;
             case CB_PL_ENTITY_EQUIPMENT:
               return ClientboundEntityEquipment;
             case CB_PL_EXPERIENCE:
               return ClientboundExperience;
             case CB_PL_UPDATE_HEALTH:
               return ClientboundUpdateHealth;
             case CB_PL_SCOREBOARD_OBJECTIVE:
               return ClientboundScoreboardObjective;
             case CB_PL_SET_PASSENGERS:
               return ClientboundSetPassengers;
             case CB_PL_TEAMS:
               return ClientboundTeams;
             case CB_PL_SCOREBOARD_SCORE:
               return ClientboundScoreboardScore;
             case CB_PL_UPDATE_TIME:
               return ClientboundUpdateTime;
             case CB_PL_TITLE:
               return ClientboundTitle;
             case CB_PL_ENTITY_SOUND_EFFECT:
               return ClientboundEntitySoundEffect;
             case CB_PL_SOUND_EFFECT:
               return ClientboundSoundEffect;
             case CB_PL_STOP_SOUND:
               return ClientboundStopSound;
             case CB_PL_PLAYERLIST_HEADER:
               return ClientboundPlayerlistHeader;
             case CB_PL_NBT_QUERY_RESPONSE:
               return ClientboundNbtQueryResponse;
             case CB_PL_COLLECT:
               return ClientboundCollect;
             case CB_PL_ENTITY_TELEPORT:
               return ClientboundEntityTeleport;
             case CB_PL_ADVANCEMENTS:
               return ClientboundAdvancements;
             case CB_PL_ENTITY_UPDATE_ATTRIBUTES:
               return ClientboundEntityUpdateAttributes;
             case CB_PL_ENTITY_EFFECT:
               return ClientboundEntityEffect;
             case CB_PL_DECLARE_RECIPES:
               return ClientboundDeclareRecipes;
             case CB_PL_TAGS:
               return ClientboundTags;
            default:
              runtime_error("Invalid Packet Id");
          }
        case SERVERBOUND:
          switch(packet_id) {
             case SB_PL_TELEPORT_CONFIRM:
               return ServerboundTeleportConfirm;
             case SB_PL_QUERY_BLOCK_NBT:
               return ServerboundQueryBlockNbt;
             case SB_PL_SET_DIFFICULTY:
               return ServerboundSetDifficulty;
             case SB_PL_CHAT:
               return ServerboundChat;
             case SB_PL_CLIENT_COMMAND:
               return ServerboundClientCommand;
             case SB_PL_SETTINGS:
               return ServerboundSettings;
             case SB_PL_TAB_COMPLETE:
               return ServerboundTabComplete;
             case SB_PL_TRANSACTION:
               return ServerboundTransaction;
             case SB_PL_ENCHANT_ITEM:
               return ServerboundEnchantItem;
             case SB_PL_WINDOW_CLICK:
               return ServerboundWindowClick;
             case SB_PL_CLOSE_WINDOW:
               return ServerboundCloseWindow;
             case SB_PL_CUSTOM_PAYLOAD:
               return ServerboundCustomPayload;
             case SB_PL_EDIT_BOOK:
               return ServerboundEditBook;
             case SB_PL_QUERY_ENTITY_NBT:
               return ServerboundQueryEntityNbt;
             case SB_PL_USE_ENTITY:
               return ServerboundUseEntity;
             case SB_PL_GENERATE_STRUCTURE:
               return ServerboundGenerateStructure;
             case SB_PL_KEEP_ALIVE:
               return ServerboundKeepAlive;
             case SB_PL_LOCK_DIFFICULTY:
               return ServerboundLockDifficulty;
             case SB_PL_POSITION:
               return ServerboundPosition;
             case SB_PL_POSITION_LOOK:
               return ServerboundPositionLook;
             case SB_PL_LOOK:
               return ServerboundLook;
             case SB_PL_FLYING:
               return ServerboundFlying;
             case SB_PL_VEHICLE_MOVE:
               return ServerboundVehicleMove;
             case SB_PL_STEER_BOAT:
               return ServerboundSteerBoat;
             case SB_PL_PICK_ITEM:
               return ServerboundPickItem;
             case SB_PL_CRAFT_RECIPE_REQUEST:
               return ServerboundCraftRecipeRequest;
             case SB_PL_ABILITIES:
               return ServerboundAbilities;
             case SB_PL_BLOCK_DIG:
               return ServerboundBlockDig;
             case SB_PL_ENTITY_ACTION:
               return ServerboundEntityAction;
             case SB_PL_STEER_VEHICLE:
               return ServerboundSteerVehicle;
             case SB_PL_CRAFTING_BOOK_DATA:
               return ServerboundCraftingBookData;
             case SB_PL_NAME_ITEM:
               return ServerboundNameItem;
             case SB_PL_RESOURCE_PACK_RECEIVE:
               return ServerboundResourcePackReceive;
             case SB_PL_ADVANCEMENT_TAB:
               return ServerboundAdvancementTab;
             case SB_PL_SELECT_TRADE:
               return ServerboundSelectTrade;
             case SB_PL_SET_BEACON_EFFECT:
               return ServerboundSetBeaconEffect;
             case SB_PL_HELD_ITEM_SLOT:
               return ServerboundHeldItemSlot;
             case SB_PL_UPDATE_COMMAND_BLOCK:
               return ServerboundUpdateCommandBlock;
             case SB_PL_UPDATE_COMMAND_BLOCK_MINECART:
               return ServerboundUpdateCommandBlockMinecart;
             case SB_PL_SET_CREATIVE_SLOT:
               return ServerboundSetCreativeSlot;
             case SB_PL_UPDATE_JIGSAW_BLOCK:
               return ServerboundUpdateJigsawBlock;
             case SB_PL_UPDATE_STRUCTURE_BLOCK:
               return ServerboundUpdateStructureBlock;
             case SB_PL_UPDATE_SIGN:
               return ServerboundUpdateSign;
             case SB_PL_ARM_ANIMATION:
               return ServerboundArmAnimation;
             case SB_PL_SPECTATE:
               return ServerboundSpectate;
             case SB_PL_BLOCK_PLACE:
               return ServerboundBlockPlace;
             case SB_PL_USE_ITEM:
               return ServerboundUseItem;
            default:
              runtime_error("Invalid Packet Id");
          }
        default:
          runtime_error("Invalid Packet Direction");
      }
    default:
      runtime_error("Invalid Packet State");
  }*/ return NULL;
}

